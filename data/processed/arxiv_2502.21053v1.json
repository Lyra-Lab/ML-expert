{
  "id": "arxiv_2502.21053v1",
  "text": "arXiv:2502.21053v1  [cs.LO]  28 Feb 2025\nProof systems for partial incorrectness logic\n(partial reverse Hoare logic)\nYukihiro Oda ∗\nMarch 3, 2025\nPartial incorrectness logic (partial reverse Hoare logic) has recently been introduced as\na new Hoare-style logic that over-approximates the weakest pre-conditions of a program\nand a post-condition. It is expected to verify systems where the ﬁnal state must guarantee\nits initial state, such as authentication, secure communication tools and digital signatures.\nHowever, the logic has only been given semantics. This paper deﬁnes two proof systems for\npartial incorrectness logic (partial reverse Hoare logic): ordinary and cyclic proof systems.\nThey are sound and relatively complete. The relative completeness of our ordinary proof\nsystem is proved by showing that the weakest pre-condition of a while loop and a post-\ncondition is its loop invariant. The relative completeness of our cyclic proof system is\nalso proved by providing a way to transform any cyclic proof into an ordinary proof.\n1. Introduction\nHoare-style logics, such as partial Hoare logic [18], total Hoare logic [22], and incorrectness logic[24],\nalso known as reverse Hoare logic[16], are popular logical methods for proving the correctness of\nprograms or for ﬁnding bugs, statically. They guarantee the corresponding property of a program C\nusing triples ⟨P⟩C ⟨Q⟩, where C is a program, P is a pre-condition of C, and Q is a post-condition\nof C.\nPartial Hoare logic [18] is the ﬁrst of all Hoare-style logics and guarantees {P} C {Q} its partial\ncorrectness, i.e. for any state σ, if C terminates from σ and P holds in σ, then Q holds in the ﬁnal\nstate. Partial Hoare logic does not guarantee the termination of a program. Total Hoare logic [22] is\nan extension of partial Hoare logic that guarantees termination.\nThe partial correctness of {P} C {Q} can be restated as follows:\nthe post-condition Q over-\napproximates the strongest post-condition of P and C, i.e. the set of ﬁnal states in which C ter-\nminates from a state in which P holds. In contrast, incorrectness logic [24], also known as reverse\nHoare logic [16], guarantees [[P] C [Q]] that the post-condition Q under-approximates the strongest\npost-condition of P and C. This logic is a method for proving the existence of bugs in C rather than\nproving correctness [24, 26]. This is why the logic is called “incorrectness” logic.\nL. Zhang and B. L. Kaminski [44] deﬁned partial incorrectness logic. It was found by investigat-\ning the relation between Hoare-style logics and predicate transformers, i.e. weakest pre-condition,\nweakest liberal pre-condition, strongest post-condition, and strongest liberal post-condition. Table 1\nsummarises their results [44]. The logic guarantees [P] C [Q] the following: if Q holds in a state in\nwhich C terminates from a state σ, then P holds in σ.\n∗Tohoku University, yukihiro3socrates6hilbert [at] gmail.com\n1\n\n\nLogic\nPre-condition\nPost-condition\nTotal Hoare logic {{P} C {Q}}\nP ⇒wpr(C, Q)\nNone\nPartial Hoare logic {P} C {Q}\nP ⇒wlpr(C, Q)\nspo(P, C) ⇒Q\nPartial incorrectness logic (Partial reverse Hoare logic) [P] C [Q]\nwpr(C, Q) ⇒P\nQ ⇒slpo(P, C)\n(Total) incorrectness logic (reverse Hoare logic) [[P] C [Q]]\nNone\nQ ⇒spo(P, C)\nσ |= wpr(C, Q) ⇔∃σ′\u0000⟨C, σ⟩→⟨ε, σ′⟩∧σ′ |= Q\n\u0001\n(Weakest pre-condition)\nσ |= wlpr(C, Q) ⇔∀σ′\u0000⟨C, σ⟩→⟨ε, σ′⟩⇒σ′ |= Q\n\u0001\n(Weakest liberal pre-condition)\nσ′ |= spo(P, C) ⇔∃σ\n\u0000⟨C, σ⟩→⟨ε, σ′⟩∧σ |= P\n\u0001\n(Strongest post-condition)\nσ′ |= slpo(P, C) ⇔∀σ\n\u0000⟨C, σ⟩→⟨ε, σ′⟩⇒σ |= P\n\u0001\n(Strongest liberal post-condition)\nTable 1: Triples and Pre-condition/post-condition (Similar to the table on [44, p.87:20])\nThe logic was named “partial incorrectness logic”, perhaps because of the relation with total Hoare\nlogic. It is like the relation between partial Hoare logic and incorrectness logic (reverse Hoare logic).\nActually, incorrectness logic (reverse Hoare logic) is a total logic because it requires the termination\nof a target program [16]. Because the logic is not so, it is a partial logic. However, as we will see\nlater, the logic is to prove “correctness”, not to ﬁnd bugs. Therefore, in this paper, we mainly refer\nto it as partial reverse Hoare logic.\nTo see the usefulness of partial reverse Hoare logic, we describe the case of a password-based\nauthentication system given by L. Zhang and B. L. Kaminski [44]. Consider a program CAuth for\na password-based authentication system that takes as input “username”, “password”, and so on,\nand then outputs “approved” if the user is identiﬁed and “rejected” otherwise. When we check this\nprogram using Hoare-style logic, we naively think the following triple:\n⟨username = x, password = y, . . . are correct⟩CAuth ⟨“approved”⟩.\n(1)\nIf (1) were proved in partial Hoare logic, then the program would be guaranteed the following: the\nprogram outputs “approved” if the inputs are correct. But, this is wrong: it does not guarantee that\nthe wrong user will be rejected. Someone might think that we just need to show the following triple:\n⟨username = x, password = y, . . . are not correct⟩CAuth ⟨“rejected”⟩.\n(2)\nBut this means that we have to show two triples, which takes time and eﬀort. Moreover, this is\nover-engineering: this analysis consequently guarantees that the program outputs “approved” if and\nonly if the inputs are correct, even if unexpected errors occur. This problem occurs in total Hoare\nlogic.\nIf (1) were proved in incorrectness logic (reverse Hoare logic), then the program would be guar-\nanteed that the inputs could be correct if the program outputs “approved”. It guarantees nothing.\nSomeone might think that, considering (2), all is well. But they are wrong. If (2) were proved in\nreverse Hoare logic, then it would only guarantee that the inputs could not be correct if the program\noutputs “rejected”. This is not what we want to guarantee. From the view of “incorrectness”, we\nmay have to prove the following triple, which means that there are some bugs in CAuth:\n⟨username = x, password = y, . . . are not correct⟩CAuth ⟨“approved”⟩.\nOn the other hand, this means that in this case, incorrectness logic can ﬁnd bugs but cannot guarantee\n“correctness”.\nNow, suppose that (1) is proved in partial reverse Hoare logic.\nIn this case, the inputs must\nbe correct if the program outputs “approved”. This is what we want to guarantee for CAuth. It\n2\n\n\nalso solved the problem of over-engineering problem in partial Hoare logic. This result allows the\nsituation where the program outputs “rejected” if the inputs are correct, but an unexpected error\noccurs. In this example, “incorrectness” is not essential. When we prove (1), we do not ﬁnd any bugs\nin CAuth, but we show the “reverse-correctness” of CAuth. Then, in our opinion, the name “partial\nincorrectness logic” is not appropriate. We would like to call the logic “partial reverse Hoare logic”.\nAs we see in the above case, partial reverse Hoare logic is useful for verifying systems in which\nthe ﬁnal state must guarantee its initial state, such as authentication, secure communication tools,\nand digital signatures. L. Verscht, ¯A. W´ang and B. L. Kaminski [42] also give some useful cases of\npartial reverse Hoare logic.\n1.1. Our contribution\nOur main contribution is to deﬁne two proof systems for partial incorrectness logic (partial reverse\nHoare logic): ordinary and cyclic proof systems.\nThese systems, which are sound and relatively\ncomplete, will have practical applications in software veriﬁcation for secure systems. While L. Zhang\nand B. L. Kaminski [44] deﬁned the semantics of partial incorrectness logic, they did not give its\nproof system. Therefore, our systems are the ﬁrst for partial reverse Hoare logic, opening up new\npossibilities for practical use and further research in the ﬁeld.\nIn our ordinary proof system, where every proof ﬁgure is a ﬁnite tree, the rule for the while loop\nis the dual of the corresponding rule in “partial” Hoare logic, not in “total” Hoare logic. We note\nthat the semantics of partial reverse Hoare logic is the dual of total Hoare logic, so there is a twist.\nThis twist is very interesting, but we do not know why.\nCyclic proof systems are proof systems that allow cycles in proof ﬁgures. When the rule for the\nwhile loop is applied in our ordinary proof system, we have to ﬁnd a good loop invariant, just as in\npartial Hoare logic, which is challenged [17]. In contrast, we do not have to ﬁnd loop invariants when\nthe while loop rule is applied in our cyclic proof system. Hence, cyclic proofs have an advantage in\nproof search.\nWe give outlines for proofs of the relative completeness. We show the relative completeness of our\nordinary proof system by showing that the weakest pre-condition predicate of a while loop and a\npost-condition is its loop invariant. We also prove that of our cyclic proof system by giving a way to\ntransform any cyclic proof into an ordinary proof.\n1.2. Related work\nWe present related work.\nThe results in Hoare logic are too numerous to be presented here. However, there is a detailed\nsurvey of Hoare logic by K. R. Apt and E. Olderog [3]. One of the most important recent extensions of\nHoare logic is separation logic, which is used to reason about pointer structures [25, 28]. It is applied\nin Infer[12], used by Meta, Prusti[4], a veriﬁer for Rust, and Iris[19], implemented and veriﬁed in\nCoq, and so on.\nIncorrectness logic [24], reverse Hoare logic [16], is used mainly to ﬁnd bugs. It has been extended\nby separation logic to incorrectness separation logic [26] and concurrent incorrectness separation logic\n[27]. Y. Lee and K. Nakazawa [21] showed the relative completeness of incorrectness separation logic.\nAs mentioned above, partial incorrectness logic (partial reverse Hoare logic) was found by inves-\ntigating the relation between Hoare-style logics and predicate transformers [44].\nL. Verscht and\nB. L. Kaminski [41] investigated this relation in more detail. L. Verscht, ¯A. W´ang and B. L. Kamin-\nski [42] introduced partial incorrectness logic from the point of view of predicate transformers and\ndiscussed some useful cases.\nNon-well-founded proof systems are a type of proof system that allows a proof ﬁgure to contain\ninﬁnite paths. Cyclic, or circular, proof systems are a type of non-well-founded proof system. It\n3\n\n\nallows a proof ﬁgure to contain cycles. R. N. S. Rowe [29] summarises the extensive list of academic\nwork on cyclic and non-well-founded proof theory.\nCyclic proofs are deﬁned for some logics or\ntheories to reason about inductive or recursive structures, such as modal µ-calculus [1], G¨odel-\nL¨ob provability logic [33], ﬁrst-order logic with inductive deﬁnitions [11, 5, 23], arithmetic[34, 15],\nseparation logic [7, 8, 37, 20, 31, 32]. Cyclic proofs are also useful for software veriﬁcation because\nof their ﬁniteness, for example, abduction [9], termination of pointer programs [7, 30], temporal\nproperty veriﬁcation[38], solving horn clauses [40], model checking[39], and decision procedures for\nsymbolic heaps [10, 13, 35, 36, 37].\n1.3. Outline of this paper\nWe outline the rest of this paper. Section 2 introduces the syntax and operational semantics of our\nnon-deterministic target language. In Section 3, we deﬁne an ordinary proof system for partial reverse\nHoare logic and show its soundness and relative completeness. Section 4 gives cyclic proofs and shows\nthat their provability is the same as that of our ordinary proof system. Section 5 concludes.\n2. Programs and assertions\nThis section introduces the syntax and semantics of our non-deterministic target languages.\nLet N be the whole of natural numbers, that is {0, 1, . . .}, and Var be an inﬁnite set of variables.\nExpressions E, Boolean conditions B, programs C, and Assertions P are deﬁned as the following\ngrammar:\nE ::= x | n | f(E, . . . , E),\nB ::= Q(E, . . . , E) | E = E | E ≤E | ¬B | B ∧B | B ∨B,\nC ::= ε | C′\nC′ ::= x := E | C′; C′ | while B do C od | either C or C ro,\nP ::= B | ¬P | P ∨P | P ∧P | P →P | ∃x(P) | ∀x(P)\nwhere ε denotes the empty string, and x, n, f and Q range over Var, N, the set of functions N →N\nand the set of predicates or relations on N, respectively.\nFor simplicity, we restrict control ﬂow statements to only while B do C od and either C0 or C1 ro.\nHowever, many control ﬂow statements can be simulated in our language. For example, if B then C0 else C1\ncan be simulated by x := 0; while B ∧x = 0 do C0; x := 1 od; while ¬B ∧x = 0 do C1; x := 1 od\nwith some fresh variable x.\nIn each occurrence of the form ∃x(P) and ∀x(P), we say that the occurrence x is binding with\nscope P. We say that an occurrence of a variable is bound if it is a binding occurrence of the variable.\nAn occurrence of a variable is called free if it is not bound. As usual, we assume that α-conversions\n(renaming of bound variables) are implicitly applied in order that bound variables are always diﬀerent\nfrom each other and from free variables. We write FV(P) for the set of free variables occurring in an\nassertion P. We write Var(E), Var(B), and Var(C), for the set of variables occurring in expression\nE, Boolean condition B, and program C. As usual, we write E0 ̸= E1 for ¬(E0 = E1) and E0 > E1\nfor ¬(E0 ≤E1). We write E[x 7→E′] and B[x 7→E′] to denote the substitution of expression E′ for\nvariable x in expression E and Boolean condition B, respectively. We write P[x0 7→E0, . . . , xn 7→En]\nfor the assertion obtained by replacing all the free occurrences of x0, . . . , xn in P with E0, . . . , En.\nFor Q1, . . . , Qn ∈{∃, ∀}, we abbreviate Q1x1(. . . (Qnxn(P)) . . . ) to Q1x1 . . . Qnxn(P). For programs\nC0 and C1, we write C0; C1 for Ci if C1−i ≡ε and C0; C1 otherwise.\nA (program) state is deﬁned as a function σ: Var →N. We deﬁne the semantics [[E]]σ ∈N and\n4\n\n\n[[B]]σ ∈{⊤, ⊥} of expression E and Boolean condition B in state σ in the usual way:\n[[n]]σ = n\nfor a natural number n,\n[[x]]σ = σ(x)\nfor x ∈Var,\n[[f(E0, . . . , En)]]σ = f([[E0]]σ, . . . , [[En]]σ),\n[[Q(E0, . . . , En)]]σ = ⊤⇔([[E0]]σ, . . . , [[En]]σ) ∈Q,\n[[E = E′]]σ = ⊤⇔[[E]]σ = [[E′]]σ,\n[[E ≤E′]]σ = ⊤⇔[[E]]σ ≤[[E′]]σ,\n[[¬B]]σ = ⊤⇔[[B]]σ = ⊥,\n[[B ∧B′]]σ = ⊤⇔[[B]]σ = ⊤and [[B′]]σ = ⊤,\n[[B ∨B′]]σ = ⊤⇔[[B]]σ = ⊤or [[B′]]σ = ⊤.\nWe write σ[x 7→E] for the state deﬁned as σ on all variables except x, with σ[x 7→E](x) = [[E]]σ.\nLemma 2.1. For all expressions E and E′, Boolean expressions B, program states σ and variables\nx, the following statements hold:\n[[E\n\u0002\nx 7→E′\u0003\n]]σ = [[E]](σ\u0002\nx 7→[[E′]]σ\n\u0003\n), and\n[[B[x 7→E]]]σ ⇔[[B]](σ[x 7→[[E]]σ]).\nProof. By structural induction on E and B, respectively.\nSatisfaction of an assertion P by a state σ, written σ |= P, is deﬁned inductively as follows:\nσ |= B ⇔[[B]]σ = ⊤,\nσ |= ¬P0 ⇔σ ̸|= P0,\nσ |= P0 ∨P1 ⇔σ |= P0 or σ |= P1,\nσ |= P0 ∧P1 ⇔σ |= P0 and σ |= P1,\nσ |= P0 →P1 ⇔σ ̸|= P0 or σ |= P1,\nσ |= ∃x(P0) ⇔σ[x 7→c] |= P0 for some c,\nσ |= ∀x(P0) ⇔σ[x 7→c] |= P0 for all c.\nFor assertions P and Q, we write P |= Q if σ |= P implies σ |= Q for any state σ. For an assertion\nP, we write |= P if σ |= P holds for any state σ.\nLemma 2.2 (Substitution). For all assertions P, program states σ, expressions E and variables x,\nσ |= P[x 7→E] if and only if σ[x 7→[[E]]σ] |= P.\nProof sketch. The ‘if’ part: By structural induction on P.\nThe ‘only if’ part: By structural induction on P[x 7→E].\nA (program) conﬁguration is deﬁned as a pair ⟨C, σ⟩, where C and σ are a program and a state,\nrespectively. In Figure 1, we deﬁne the operational semantics of our programs by giving the small-\nstep relation −→on conﬁgurations. An execution (of C) is deﬁned as a possibly inﬁnite sequence of\nconﬁgurations (⟨Ci, σi⟩)i≥0 with C0 = C such that ⟨Ci, σi⟩−→⟨Ci, σi+1⟩for all i ≥0. For a ﬁnite\nexecution (⟨Ci, σi⟩)0≤i≤n, the length of the ﬁnite execution is deﬁned as n. We write −→n for an\nn-step execution. We also sometimes write −→∗for the reﬂexive-transitive closure of −→.\nLemma 2.3. The following statements hold:\n5\n\n\n⟨x := E, σ⟩−→⟨ε, σ[x 7→[[E]]σ]⟩\n(assign)\n⟨while B do C od, σ⟩−→⟨C; while B do C od, σ⟩\nif [[B]]σ = ⊤\n(while 1)\n⟨while B do C od, σ⟩−→⟨ε, σ⟩\nif [[B]]σ = ⊥\n(while 2)\n⟨C0; C1, σ⟩−→⟨C′\n0; C1, σ′⟩\nif ⟨C0, σ⟩−→⟨C′\n0, σ′⟩\n(seq)\n⟨either C0 or C1 ro, σ⟩−→⟨Ci, σ⟩\nfor i = 0, 1\n(or i)\nFigure 1: Small-step semantics of programs\n(1) For a program C, states σ, σ′, and a variable z /∈Var(C), if ⟨C, σ⟩−→∗⟨ε, σ′⟩holds, then\nσ(z) = σ′(z) holds.\n(2) For a program C, states σ, σ′, and a variable z /∈Var(C), if ⟨C, σ[z 7→a]⟩−→∗⟨ε, σ′[z 7→a]⟩\nholds, then ⟨C, σ[z 7→[[z]]σ′]⟩−→∗⟨ε, σ′⟩holds.\n(3) For programs C0 and C1, and states σ and σ′, ⟨C0; C1, σ⟩−→∗⟨ε, σ′⟩holds if and only if there\nexists σ′′ such that ⟨C0, σ⟩−→∗⟨ε, σ′′⟩and ⟨C1, σ′′⟩−→∗⟨ε, σ′⟩hold.\n(4) Let B be a Boolean condition, and C be a program. For states σ and σ′, ⟨while B do C od, σ⟩−→∗\n⟨ε, σ′⟩holds if and only if there exist states σ0, . . . , σk such that σ0 ≡σ, σk ≡σ′ and σk |= ¬B\nhold, and k > 0 implies that ⟨C, σi⟩−→∗⟨ε, σi+1⟩and σi |= B for each i = 0, . . . , k −1.\nProof(Sketch). We give the outline of proof of each statement.\n(1) By induction on the length of ⟨C, σ⟩−→∗⟨ε, σ′⟩.\n(2) By induction on the length of ⟨C, σ[z 7→a]⟩−→∗⟨ε, σ′[z 7→a]⟩.\n(3) By induction on the length of ⟨C0; C1, σ⟩−→∗⟨ε, σ′⟩.\n(4) The ‘if’ part: By induction on k.\nThe ‘only if’ part: By induction on the length of ⟨while B do C od, σ⟩−→∗⟨ε, σ′⟩.\n3. An ordinary proof system for partial incorrectness logic (partial\nreverse Hoare logic)\nThis section introduces partial incorrectness logic (partial reverse Hoare logic) and its ordinary proof\nsystem. Our proof system is similar to partial Hoare logic, except for the composition rule and the\nrule for while B do C od. Interestingly, although the semantics of partial reverse Hoare logic is the\ndual of “total” Hoare logic, the rule for while B do C od is the dual of the corresponding rule in\n“partial” Hoare logic, not in total Hoare logic.\nWe write partial reverse Hoare triples as [P] C [Q], where C is a program, and P and Q are\nassertions. Partial reverse Hoare triples are the same as partial incorrectness triples [44, 41]. As we\nsaid in Section 1, “incorrectness” is not essential for partial reverse Hoare logic. That is why we do\nnot use the term “partial incorrectness triples”.\nDeﬁnition 3.1. A partial reverse Hoare triple [P] C [Q] is said to be valid if, for all states σ′ with\nσ′ |= Q, the following state holds: for any state σ, if ⟨C, σ⟩−→∗⟨ε, σ′⟩holds, then σ |= P.\nThis deﬁnition is equivalent to Deﬁnition 6.4 in [44], which is shown in [44, p.87:20]. To see the\nequivalence, we describe the relationship between the validity of partial reverse Hoare triples and the\nweakest pre-condition.\n6\n\n\n(AxiomRHL)\n[Q] ε [Q]\n(:=PRHL)\n[Q[x 7→E]] x := E [Q]\n[P] C0 [R]\n[R] C1 [Q] (SeqRHL)\n[P] C0; C1 [Q]\n[P] C [Q]\n(P |= P ′, Q′ |= Q)\n(ConsRHL)\n[P ′] C [Q′]\n[P] C0 [Q]\n[P] C1 [Q]\n(OrPRHL)\n[P] either C0 or C1 ro [Q]\n[B →P] C [P]\n(WhilePRHL)\n[P] while B do C od [¬B →P]\nFigure 2: The rules for our ordinary proof system of partial incorrectness logic (partial reverse Hoare\nlogic)\nDeﬁnition 3.2 (Weakest pre-condition). For an assertion Q and a program C, we deﬁne a set of\nstates WPR(C, Q) by:\nWPR(C, Q) =\n(\nσ\n\f\f\f\f\f\nThere exists a state σ′ such that\n⟨C, σ⟩−→∗⟨ε, σ′⟩and σ′ |= Q hold\n)\n.\nIntuitively, σ ∈WPR(C, Q) holds if and only if C terminates from σ and the ﬁnal state satisﬁes\nQ. Then, we see the following statement, which means that Deﬁnition 3.1 is equivalent to Deﬁnition\n6.4 in [44].\nProposition 3.3. [P] C [Q] is valid if and only if WPR(C, Q) ⊆{σ | σ |= P} holds.\nProof. The ‘if’ part: Assume WPR(C, Q) ⊆{σ | σ |= P}. Fix a state σ′ with σ′ |= Q. Fix a state σ\nwith ⟨C, σ⟩−→∗⟨ε, σ′⟩. Then, σ ∈WPR(C, Q) holds. Because of WPR(C, Q) ⊆{σ | σ |= P}, we\nhave σ |= P. Thus, [P] C [Q] is valid.\nThe ‘only if’ part: Assume that [P] C [Q] is valid.\nLet σ ∈WPR(C, Q).\nThen, there exists a\nstate σ′ such that ⟨C, σ⟩−→∗⟨ε, σ′⟩and σ′ |= Q hold.\nSince [P] C [Q] is valid, σ |= P.\nThus,\nWPR(C, Q) ⊆{σ | σ |= P} holds.\nFigure 2 shows the inference rules for our proof system of partial reverse Hoare logic. We note two\npoints about these rules.\nFirstly, our rule for assignment is similar to that in Hoare logic, not in (total) reverse Hoare logic.\nThe naive translation of (:=PRHL)\n[[Q[x 7→E]] x := E [Q]]\nis not sound and complete in (total) reverse Hoare logic (see [16, p.159] for details). However, (:=PRHL)\nis sound and complete in partial reverse Hoare logic, as we show later.\nSecondly, assertions in our rule for the while loop are the dual of these in partial Hoare logic. The\npopular rule for the while loop in partial Hoare logic is as follows:\n{B ∧P} C {P}\n{P} while B do C od {¬B ∧P}\n.\nWe note that P ∧B |= P ′ is equivalent to P |= B →P ′. Interestingly, (WhilePRHL) is sound and\ncomplete in partial reverse Hoare logic. As we see in Section 1, the semantics of partial reverse Hoare\nlogic is the dual of “total” Hoare logic. However, the rule is not so; it is the dual of partial Hoare\nlogic. This fact is very interesting, but we do not understand why the twist exists.\n7\n\n\nWe call P in (WhilePRHL) a loop invariant of while B do C od.\nWe deﬁne a PRHL-proof as a derivation tree constructed according to the proof rules in Figure 2,\neach leaf of which is a conclusion of either (AxiomRHL) or (:=PRHL). If there is a PRHL-proof whose\nroot is labelled by [P] C [Q], we say that [P] C [Q] is provable in PRHL.\nExample 3.4. Let + addition operator. The following is a PRHL-proof:\n(:=PRHL)\n[⊤] x := x + i [⊤]\n(ConsRHL)\n[i < 5 →⊤] x := x + i [⊤]\n(:=PRHL)\n[⊤] i := i + 1 [⊤]\n(ConsRHL)\n[i < 5 →⊤] i := i + 1 [⊤] (SeqRHL)\n[i < 5 →⊤] x := x + i; i := i + 1 [⊤]\n(WhilePRHL)\n[⊤] while i < 5 do x := x + i; i := i + 1 od [¬(i < 5) →⊤] (ConsRHL)\n[⊤] while i < 5 do x := x + i; i := i + 1 od [x > 0 ∧i ≥5]\n.\nWe show the soundness theorem.\nProposition 3.5 (Soundness). If [P] C [Q] is provable in PRHL, then it is valid.\nProof. It suﬃces to show the local soundness of each rule: if all the premises are valid, then the\nconclusion is valid.\nCase(AxiomRHL). Obvious.\nCase(:=PRHL). We show that [Q[x 7→E]] x := E [Q] is valid.\nFix a state σ′ with σ′ |= Q. Fix a state σ with ⟨x := E, σ⟩−→∗⟨ε, σ′⟩. Since ⟨x := E, σ⟩−→∗⟨ε, σ′⟩\nholds, we have σ′ ≡σ[x 7→[[E]]σ]. Because of σ[x 7→[[E]]σ] |= Q, Lemma 2.2 implies σ |= Q[x 7→E].\nCase(SeqRHL). Assume that [P] C0 [R] and [R] C1 [Q] are valid. We show that [P] C0; C1 [Q] is valid.\nFix a state σ′ with σ′ |= Q. Fix a state σ with ⟨C0; C1, σ⟩−→∗⟨ε, σ′⟩. By Lemma 2.3 (3), there\nexists σ′′ such that ⟨C0, σ⟩−→∗⟨ε, σ′′⟩and ⟨C1, σ′′⟩−→∗⟨ε, σ′⟩hold. Since [R] C1 [Q] is valid, we\nhave σ′′ |= R. Since [P] C0 [R] is valid, we have σ |= P.\nCase(ConsRHL). Assume that [P] C [Q] is valid, and both P |= P ′ and Q′ |= Q hold. We show that\n[P ′] C [Q′] is valid.\nFix a state σ′ with σ′ |= Q′. Fix a state σ with ⟨C, σ⟩−→∗⟨ε, σ′⟩. Because of Q′ |= Q, we have\nσ′ |= Q. Since [P] C [Q] is valid, σ |= P. Because of P |= P ′, we have σ |= P ′.\nCase(OrPRHL). Assume that [P] C0 [Q] and [P] C1 [Q] are valid. We show that [P] either C0 or C1 ro [Q]\nis valid.\nFix a state σ′ with σ′ |= Q′. Fix a state σ with ⟨either C0 or C1 ro, σ⟩−→∗⟨ε, σ′⟩. Assume that\n⟨either C0 or C1 ro, σ⟩−→⟨C0, σ⟩−→∗⟨ε, σ′⟩. Since ⟨C0, σ⟩−→∗⟨ε, σ′⟩holds and [P] C0 [Q] is\nvalid, we have σ |= P.\nIn the same way, we have σ |= P if ⟨either C0 or C1 ro, σ⟩−→⟨C1, σ⟩−→∗⟨ε, σ′⟩holds. Thus,\n[P] either C0 or C1 ro [Q] is valid.\nCase(WhilePRHL). Assume that [B →P] C [P] is valid. We show that [P] while B do C od [¬B →P]\nis valid.\nFix a state σ′ with σ′ |= ¬B →P. Fix a state σ with ⟨while B do C od, σ⟩−→∗⟨ε, σ′⟩. By\nLemma 2.3 (4), there exist states σ0, . . . , σk such that σk ≡σ, σ0 ≡σ′, σ0 |= ¬B, ⟨C, σi⟩−→∗\n⟨ε, σi−1⟩, and σi |= B hold for each i = 1, . . . , k. We show σi |= P for each i = 0, . . . , k. The proof\nprogresses by induction on i.\nAssume i = 0. Then, σ0 ≡σ′ holds. Since σ0 |= ¬B and σ0 |= ¬B →P hold, we have σ0 |= P.\nAssume i > 0. Then, we have ⟨C, σi⟩−→∗⟨ε, σi−1⟩. By induction hypothesis, we have σi−1 |= P.\nSince [B →P] C [P] is valid, we have σi |= B →P. Because of σi |= B, we see σi |= P.\nThen, we have σk |= P. Since σk ≡σ, we have σ |= P.\nOur proof system is relatively complete if the expressiveness of the assertion language is suﬃcient,\nas in other Hoare-style logics (see [14, 2, 43, 16, 24, 3, 21]). We say that the language of assertions\n8\n\n\nis WPR-expressive if the following statement holds: for any assertion Q and any program C, there\nexists an assertion P such that σ ∈WPR(C, Q) holds if and only if σ |= P holds. If a language\nof assertions includes some arithmetic operators, the language of assertions is WPR-expressive. We\ngive how to construct a weakest pre-condition assertion wpr(C, Q) with some arithmetic operators\nin Appendix A.\nTheorem 3.6 (Relative completeness). If the language of assertions is WPR-expressive, then any\nvalid partial reverse Hoare triple [P] C [Q] is provable in PRHL.\nIn the remainder of this paper, we assume that the language of assertions is WPR-expressive.\nFor an assertion Q and a program C, we write wpr(C, Q) for an assertion satisfying the following\ncondition: σ ∈WPR(C, Q) holds if and only if σ |= wpr(C, Q) holds.\nTo show Theorem 3.6, we show some lemmata.\nLemma 3.7. [P] C [Q] is valid if and only if wpr(C, Q) |= P holds.\nProof. The ‘if’ part: Assume wpr(C, Q) |= P. Fix σ′ with σ′ |= Q. Fix a state σ with ⟨C, σ⟩−→∗\n⟨ε, σ′⟩. Then, σ ∈WPR(C, Q) holds. By the deﬁnition of wpr(C, Q), σ |= wpr(C, Q) holds. By\nassumption, σ |= P. Thus, [P] C [Q] is valid.\nThe ‘only if’ part: Assume that [P] C [Q] is valid. Let σ with σ |= wpr(C, Q). By the deﬁnition of\nwpr(C, Q), σ ∈WPR(C, Q) holds. By Proposition 3.3, we have WPR(C, Q) ⊆{σ | σ |= P}. Then,\nσ |= P holds. Thus, wpr(C, Q) |= P holds.\nLemma 3.8. [wpr(C, Q)] C [Q] is valid.\nProof. By Lemma 3.7.\nLemma 3.9. Following statements hold:\n(1) σ |= wpr(ε, Q) holds if and only if σ |= Q holds.\n(2) σ |= wpr(x := E, Q) holds if and only if σ |= Q[x 7→E] holds.\n(3) σ |= wpr(C0; C1, Q) holds if and only if σ |= wpr(C0, wpr(C1, Q)) holds.\n(4) σ |= wpr(either C0 or C1 ro, Q) holds if and only if σ |= wpr(C0, Q) ∨wpr(C1, Q) holds.\nProof. We show each statement.\n(1) The ‘if’ part: Assume σ |= Q. Because of ⟨ε, σ⟩−→∗⟨ε, σ⟩, we have σ |= wpr(ε, Q).\nThe ‘only if’ part: Assume σ |= wpr(ε, Q). By deﬁnition of wpr(ε, Q), we have ⟨ε, σ⟩−→∗⟨ε, σ⟩and\nσ |= Q. Then, we see σ |= Q.\n(2) The ‘if’ part: Assume σ |= Q[x 7→E]. Then, we have ⟨x := E, σ⟩−→⟨ε, σ[x 7→[[E]]σ]⟩. Because\nof σ |= Q[x 7→E], we have σ[x 7→[[E]]σ] |= Q. Thus, σ |= wpr(C, Q) holds.\nThe ‘only if’ part: Assume σ |= wpr(x := E, Q). Then, we have ⟨x := E, σ⟩−→⟨ε, σ[x 7→[[E]]σ]⟩\nand σ[x 7→[[E]]σ] |= Q. By Lemma 2.2, σ |= Q[x 7→E] holds.\n(3) The ‘if’ part: Assume σ |= wpr(C0, wpr(C1, Q)). Hence, there exists σ′′ such that ⟨C0, σ⟩−→∗\n⟨ε, σ′′⟩and σ′′ |= wpr(C1, Q) hold. Therefore, there exists a state σ′ such that ⟨C1, σ′′⟩−→∗⟨ε, σ′⟩\nand σ′ |= Q. By Lemma 2.3 (3), ⟨C0; C1, σ⟩−→∗⟨ε, σ′⟩holds. Thus, σ ∈WPR(C, Q) holds.\nThe ‘only if’ part: Assume σ |= wpr(C0; C1, Q). Then, there exists a state σ′ such that ⟨C0; C1, σ⟩−→∗⟨ε, σ′⟩\nand σ′ |= Q hold. By Lemma 2.3 (3), there exists σ′′ such that ⟨C0, σ⟩−→∗⟨ε, σ′′⟩and ⟨C1, σ′′⟩−→∗\n⟨ε, σ′⟩hold. Since ⟨C1, σ′′⟩−→∗⟨ε, σ′⟩and σ′ |= Q hold, we have σ′′ ∈WPR(C1, Q). Then, we have\nσ′′ |= wpr(C1, Q). Because of ⟨C0, σ⟩−→∗⟨ε, σ′′⟩, we see σ ∈WPR(C0, wpr(C1, Q)). Then, we have\nσ |= wpr(C0, wpr(C1, Q)).\n9\n\n\n(4) The ‘if’ part: Assume σ |= wpr(C0, Q) ∨wpr(C1, Q).\nThen, either σ |= wpr(C0, Q) or σ |=\nwpr(C1, Q) holds.\nAssume σ |= wpr(C0, Q). Then, there exists a state σ′ such that ⟨C0, σ⟩−→∗⟨ε, σ′⟩and σ′ |= Q\nhold.\nBecause ⟨either C0 or C1 ro, σ⟩−→⟨C0, σ⟩holds, we have ⟨either C0 or C1 ro, σ⟩−→∗\n⟨ε, σ′⟩. Hence, we have σ |= wpr(either C0 or C1 ro, Q).\nIn the similar way, we have σ |= wpr(either C0 or C1 ro, Q) if σ |= wpr(C1, Q) holds.\nThe ‘only if’ part: Assume σ |= wpr(either C0 or C1 ro, Q). Then, there exists a state σ′ such that\n⟨either C0 or C1 ro, σ⟩−→∗⟨ε, σ′⟩and σ′ |= Q hold. We see either ⟨either C0 or C1 ro, σ⟩−→\n⟨C0, σ⟩−→∗⟨ε, σ′⟩or ⟨either C0 or C1 ro, σ⟩−→⟨C1, σ⟩−→∗⟨ε, σ′⟩holds. Hence, we have either\nσ |= wpr(C0, Q) or σ |= wpr(C1, Q). Thus, σ |= wpr(C0, Q) ∨wpr(C1, Q) holds.\nNow, we show Theorem 3.6.\nProof of Theorem 3.6. Assume that [P] C [Q] is valid. We show [P] C [Q] is provable in PRHL. The\nproof is by induction on construction of C.\nCase(C ≡ε). Since [P] C [Q] is valid, Lemma 3.7 and Lemma 3.9 (1) imply that Q |= P. We have\na proof of [P] C [Q] as follows:\n(AxiomRHL)\n[Q] ε [Q]\n(Q |= P)\n(ConsRHL)\n[P] C [Q]\n.\nCase(C ≡x := E). Since [P] C [Q] is valid, Lemma 3.7 and Lemma 3.9 (2) imply that Q[x 7→E] |=\nP. We have a proof of [P] C [Q] as follows:\n(:=PRHL)\n[Q[x 7→E]] x := E [Q] (ConsRHL)\n[P] C [Q]\n.\nCase(C ≡C0; C1). Since [P] C [Q] is valid, Lemma 3.7 and Lemma 3.9 (3) imply that wpr(C0, wpr(C1, Q)) |=\nP.\nBy Lemma 3.8, [wpr(C1, Q)] C1 [Q] is valid.\nBy induction hypothesis, [wpr(C1, Q)] C1 [Q] is\nprovable. By Lemma 3.8, [wpr(C0, wpr(C1, Q))] C0 [wpr(C1, Q)] is valid. By induction hypothesis,\n[wpr(C0, wpr(C1, Q))] C0 [wpr(C1, Q)] is provable.\nLet π0 be a proof of [wpr(C0, wpr(C1, Q))] C0 [wpr(C1, Q)]. Let π1 be a proof of [wpr(C1, Q)] C1 [Q].\nThen, we have a proof of [P] C [Q] as follows:\nπ0\n[wpr(C0, wpr(C1, Q))] C0 [wpr(C1, Q)]\nπ1\n[wpr(C1, Q)] C1 [Q] (SeqRHL)\n[wpr(C0, wpr(C1, Q))] C0; C1 [Q]\n(wpr(C0, wpr(C1, Q)) |= P)\n(ConsRHL)\n[P] C [Q]\n.\nCase(C ≡either C0 or C1 ro). Since [P] C [Q] is valid, Lemma 3.7 and Lemma 3.9 (4) imply that\nwpr(C0, Q) ∨wpr(C1, Q) |= P. By Lemma 3.8, [wpr(Ci, Q)] Ci [Q] is valid for i = 0, 1. By induction\nhypothesis, [wpr(Ci, Q)] Ci [Q] is provable for i = 0, 1. Let πi be a proof of [wpr(Ci, Q)] Ci [Q] for\ni = 0, 1. Then, we have a proof of [P] C [Q] as follows:\n10\n\n\nπ0\n[wpr(C0, Q)] C0 [Q]\n(ConsRHL)\n[wpr(C0, Q) ∨wpr(C1, Q)] C0 [Q]\nπ1\n[wpr(C1, Q)] C1 [Q]\n(ConsRHL)\n[wpr(C0, Q) ∨wpr(C1, Q)] C1 [Q] (OrPRHL)\n[wpr(C0, Q) ∨wpr(C1, Q)] either C0 or C1 ro [Q]\n(wpr(C0, Q) ∨wpr(C1, Q) |= P)\n(ConsRHL)\n[P] C [Q]\n.\nCase(C ≡while B do C0 od). To show that [P] C [Q] is provable in PRHL, we show that [B →wpr(C, Q)] C0 [wpr(C\nis valid, and Q |= ¬B →wpr(C, Q) holds.\nWe show that [B →wpr(C, Q)] C0 [wpr(C, Q)] is valid. Fix a state σ′ with σ′ |= wpr(C, Q). Fix a\nstate σ with ⟨C0, σ⟩−→∗⟨ε, σ′⟩. We show σ |= B →wpr(C, Q). Assume σ |= B. Then, we have\n⟨while B do C0 od, σ⟩−→⟨C0; while B do C0 od, σ⟩.\nBy ⟨C0, σ⟩−→∗⟨ε, σ′⟩, we have\n⟨C0; while B do C0 od, σ⟩−→∗⟨while B do C0 od, σ′⟩.\nBecause of σ′ |= wpr(C, Q), there exists σ′′ such that ⟨C, σ′⟩−→∗⟨ε, σ′′⟩and σ′′ |= Q hold. Then,\nwe have ⟨C, σ⟩−→∗⟨C, σ′⟩−→∗⟨ε, σ′′⟩and σ′′ |= Q. Hence, we have σ |= wpr(C, Q). Therefore,\nσ |= B →wpr(C, Q) holds. Thus, [B →wpr(C, Q)] C0 [wpr(C, Q)] is valid.\nWe show Q |= ¬B →wpr(C, Q). Fix a state σ with σ |= Q. Assume σ |= ¬B. Then, we have\n⟨while B do C0 od, σ⟩−→⟨ε, σ⟩.\nHence, we have σ |= wpr(C, Q). Thus, Q |= ¬B →wpr(C, Q).\nBecause [P] C [Q] is valid, Lemma 3.7 implies wpr(C, Q) |= P. Since [B →wpr(C, Q)] C0 [wpr(C, Q)]\nis valid, induction hypothesis implies that [B →wpr(C, Q)] C0 [wpr(C, Q)] is provable. Let π be a\nproof of [B →wpr(C, Q)] C0 [wpr(C, Q)]. Then, we have a proof of [P] C [Q] as follows:\nπ\n[B →wpr(C, Q)] C0 [wpr(C, Q)]\n(WhilePRHL)\n[wpr(C, Q)] while B do C0 od [¬B →wpr(C, Q)] (ConsRHL)\n[P] C [Q]\n.\n4. Cyclic proofs for partial incorrectness logic (partial reverse Hoare\nlogic)\nThis section introduces cyclic proofs for partial reverse Hoare logic.\nIn our ordinary proof system, given in Section 3, we have to ﬁnd a good loop invariant when\n(WhilePRHL) is applied. However, it is challenged to ﬁnd a suitable loop invariant [17]. In contrast,\nour cyclic proofs do not have to ﬁnd any loop invariants when the rule for the while loop is applied.\nThis point is an advantage of cyclic proofs from the view of proof search.\nFigure 3 shows the inference rules for cyclic proofs.\nTo contain cycles, the form of rules are\nchanged from that of the ordinary proof system. We note that P and Q in the rule for the while\nloop (WhileCPRHL) can be arbitrary. In other words, we do not have to ﬁnd any loop invariants when\n(WhileCPRHL) is applied.\n11\n\n\n(AxiomRHL)\n[Q] ε [Q]\n[P ′] C [Q′]\n(P ′ |= P, Q |= Q′)\n(ConsRHL)\n[P] C [Q]\n[x′ = E[x 7→x′] ∧P[x 7→x′]] C [Q] (:=CPRHL)\n[P] x := E; C [Q]\n[P] C0; C [Q]\n[P] C1; C [Q] (OrCPRHL)\n[P] either C0 or C1 ro; C [Q]\n[¬B →P] C′ [Q]\n[B →P] C; while B do C od; C′ [Q] (WhileCPRHL)\n[P] while B do C od; C′ [Q]\nFigure 3: Rules for cyclic proofs of partial incorrectness logic (partial reverse Hoare logic)\nDeﬁnition 4.1 (Cyclic proofs for reverse Hoare logic (CPRHL-proof)). A leaf of a derivation tree\nconstructed according to the proof rules in Figure 3 is said to be open if it is not the conclusion of\n(AxiomRHL). A companion of a leaf in a derivation tree is deﬁned as an inner node of the derivation\ntree labelled by the same triple as the leaf label.\nA CPRHL-pre-proof is deﬁned as a pair P = (D, L), where D is a ﬁnite derivation tree constructed\naccording to the proof rules in Figure 3 and L is a back-link function that maps each open leaf of D\nto one of its companions.\nA CPRHL-pre-proof P is called a CPRHL-proof if it satisﬁes the following global soundness condition:\nthe rules except for (ConsRHL) are applied inﬁnitely many often along each inﬁnite path in P. If\nthere is a CPRHL-proof whose root is labelled by [P] C [Q], we say that [P] C [Q] is provable in CPRHL.\nWe note that some CPRHL-pre-proofs are not ﬁnite trees because cycles are allowed in cyclic proofs.\nHowever, each CPRHL-pre-proof can be understood as a regular (possibly inﬁnite) tree whose subtrees\nare ﬁnitely many.\nExample 4.2. The following is a CPRHL-proof:\n(AxiomRHL)\n[Q] ε [Q]\n(:=CPRHL)\n[x = 10 ∧i = 4] i := i + 1 [Q] (:=CPRHL)\n[x = 6 ∧i = 4] C0 [Q] (ConsRHL)\n[¬(i < 5) →P] C0 [Q]\n[P] C [Q]\n(ConsRHL)\n[i < 6 →x + 1 = i ∧i = 1] C [Q]\n(:=CPRHL)\n[i < 5 →x = i ∧i = 0] i := i + 1; C [Q] (:=CPRHL)\n[i < 5 →P] C0; C [Q] (WhileCPRHL)\n[P] C [Q]\n,\nwhere C ≡while i < 5 do C0 od, C0 ≡x := x + i; i := i + 1, P ≡x = 0 ∧i = 0 and Q ≡x = 10 ∧i = 5,\nand the arrow indicates the pairing of the companion with the bud. We see that the global soundness\ncondition holds, immediately. When we apply (WhileCPRHL) in the root, we do not ﬁnd any loop\ninvariant.\nNow, we show the soundness of cyclic proofs. To show the soundness, we show a lemma.\nLemma 4.3. Each of the proof rules in Figure 3 has the following property: Suppose the conclusion\nof the rule [P] C [Q] is not valid, so that in particular there exist a natural number n and states\nσ, σ′ such that σ′ |= Q, ⟨C, σ⟩−→n ⟨ε, σ′⟩, and σ ̸|= P hold. Then, for some premise of the rule\n[P ′] C′ [Q′], σ′ |= Q′ holds and there exist a natural number n′ and a state σ′′ such that n′ ≤n,\nσ′′ ̸|= P ′, and ⟨C′, σ′′⟩−→n′ ⟨ε, σ′⟩hold. Moreover, for all rules except ( ConsRHL), we have n′ < n.\nProof. We show the statement for each rule.\nCase(AxiomRHL). Since the conclusion of the rule (AxiomRHL) is always valid, the assumption does\nnot hold in this case.\n12\n\n\nCase(:=CPRHL). Let P ≡P ′[x 7→E] and C ≡x := E; C′. Assume that there exists a natural number\nn and states σ, σ′ such that σ′ |= Q, ⟨C, σ⟩−→n ⟨ε, σ′⟩, and σ ̸|= P ′[x 7→E] hold.\nWe show that there exist a natural number n′ and a state σ′′ such that n′ < n, σ′′ ̸|= P ′, and\n⟨C′, σ′′⟩−→n′ ⟨ε, σ′⟩hold.\nLet σ′′ ≡σ[x 7→[[E]]σ]. Then, we have\n⟨C, σ⟩−→⟨C′, σ′′⟩−→n−1 ⟨ε, σ′⟩.\nHence, n′ is n −1. Because of σ ̸|= P ′[x 7→E], we have σ[x 7→[[E]]σ] ̸|= P ′. Hence, σ′′ ̸|= P ′ holds.\nCase(ConsRHL). Assume P ′ |= P and Q |= Q′. We also assume that there exist a natural number n\nand states σ, σ′ such that σ′ |= Q, ⟨C, σ⟩−→n ⟨ε, σ′⟩, and σ ̸|= P hold.\nWe show that σ′ |= Q′ holds and there exists a state σ′′ such that σ′′ ̸|= P ′ and ⟨C, σ′′⟩−→n ⟨ε, σ′⟩\nhold.\nBecause of Q |= Q′ and σ′ |= Q, we have σ′ |= Q′.\nLet σ′′ ≡σ. Then, we have\n⟨C, σ′′⟩−→n ⟨ε, σ′⟩.\nBecause of P ′ |= P and σ′′ ̸|= P, we have σ′′ ̸|= P ′.\nCase(WhileCPRHL). Let C ≡while B do C0 od; C′. Assume that there exist a natural number n and\nstates σ, σ′ such that σ′ |= Q, ⟨C, σ⟩−→n ⟨ε, σ′⟩, and σ ̸|= P hold.\nWe show that there exist a natural number n′ and a state σ′′ such that n′ < n, and either both σ′′ ̸|=\n¬B →P and ⟨C′, σ′′⟩−→n′ ⟨ε, σ′⟩, or both σ′′ ̸|= B →P and ⟨C0; while B do C0 od; C′, σ′′⟩−→n′\n⟨ε, σ′⟩hold. Let σ′′ ≡σ.\nAssume σ |= B. Then, we have\n⟨C, σ⟩−→⟨C0; while B do C0 od; C′, σ′′⟩−→n−1 ⟨ε, σ′⟩.\nHence, n′ is n −1. Since σ ̸|= P and σ′′ |= B holds, we have σ′′ ̸|= B →P.\nAssume σ |= ¬B. Then, we have\n⟨C, σ⟩−→⟨C′, σ′′⟩−→n−1 ⟨ε, σ′⟩.\nHence, n′ is n −1. Since σ ̸|= P and σ′′ |= ¬B holds, we have σ′′ ̸|= ¬B →P.\nWe show the soundness theorem.\nTheorem 4.4 (Soundness). If there is a CPRHL-proof of [P] C [Q], then it is valid.\nProof. Assume, for contradiction, there is a CPRHL-proof of [P] C [Q], but it is not valid. Then, there\nexist a natural number n and states σ, σ′ such that σ′ |= Q, ⟨C, σ⟩−→n ⟨ε, σ′⟩, and σ ̸|= P hold.\nWe inductively deﬁne an inﬁnite path ([Pi] Ci [Qi])i≥0 in the CPRHL-proof of [P] C [Q] and an\ninﬁnitely non-increasing sequence of natural numbers (ni)i≥0 satisfying the following conditions: for\n[Pi] Ci [Qi], there exist states σi and σ′\ni such that σi |= Pi, ⟨Ci, σi⟩−→ni ⟨ε, σ′\ni⟩, and σ′\ni ̸|= Qi.\nDeﬁne [P0] C0 [Q0] as [P] C [Q].\nAssume that [Pi−1] Ci−1 [Qi−1] is deﬁned. By the condition, [Pi−1] Ci−1 [Qi−1] is not valid. By\nLemma 4.3, there exist states σi and σ′\ni such that σi |= Pi, ⟨Ci, σi⟩−→ni ⟨ε, σ′\ni⟩, and σ′\ni ̸|= Qi. If\nit is a symbolic execution rule, then ni < ni−1 i.e. the length of the computations is monotonously\ndecreasing.\nBy the global soundness condition on CPRHL-proofs, every inﬁnite path has rules except for (ConsRHL)\napplied inﬁnitely often. By Lemma 4.3, (ni)i≥0 is an inﬁnite descending sequence of natural numbers.\nThis is a contradiction, and we conclude that [P] C [Q] is valid after all.\n13\n\n\nIn the remainder of this section, we show the relative completeness of CPRHL, i.e. the provability\nof cyclic proofs is the same as that of our ordinary proof system PRHL. We show this statement\nby giving the way to transform each PRHL-proof into a CPRHL-proof. The formal statement of the\ncompleteness is the following.\nTheorem 4.5 (Relative completeness of CPRHL). For any partial reverse Hoare triple [P] C [Q], the\nfollowing statements are equivalent:\n(1) [P] C [Q] is valid.\n(2) [P] C [Q] is provable in PRHL.\n(3) [P] C [Q] is provable in CPRHL.\nTo show Theorem 4.5, we deﬁne some concepts and show a lemma.\nDeﬁnition 4.6 (CPRHLproof with open leaves). A CPRHL-pre-proof with open leaves is a pair P =\n(D, L), where D is a ﬁnite derivation tree constructed according to the proof rules in Figure 3 and L\nis a back-link partial function assigning to some open leaf of D a companion. For a CPRHL-pre-proof\nwith open leaves P = (D, L), we call an open leaf which is not in the domain of L a proper open leaf.\nWe deﬁne a CPRHL-proof with open leaves as a pre-proof with open leaves satisfying the following\nglobal soundness condition: the rules except for (ConsRHL) applied inﬁnitely often along every inﬁnite\npath in the pre-proof with open leaves.\nWe note that a CPRHL-proof with open leaves, where there is no proper open leaf, is a CPRHL-proof.\nLemma 4.7. If [P] C [Q] is provable in PRHL then, for any program C′ and assertion R, there is a\nCPRHL-proof with open leaves of [P] C; C′ [R] such that every proper open leaf is assigned [Q] C′ [R].\nProof. We assume that [P] C [Q] is provable in PRHL. We show the statement by induction on the\nproof of [P] C [Q] in PRHL. We proceed by a case analysis on the last rule applied in the proof.\nCase(AxiomRHL). In this case, C ≡ε. Then, P ≡Q holds and the proof of [P] C [Q] is the following:\n(AxiomRHL)\n{Q} ε {Q}\n.\nNoting that P ≡Q, for arbitrary C′ and R, we have a CPRHL-proof with open leaves of {P} ε; C′ {R}\nas follows:\n{Q} C′ {R}\n.\nThe only proper open leaf in this CPRHL-proof with open leaves is assigned {Q} C′ {R}, as required.\nCase(:=PRHL). In this case, C ≡x 7→E. Then, P ≡Q[x 7→E] holds and the proof of [P] C [Q] is the\nfollowing:\n(:=PRHL)\n[Q[x 7→E]] x := E [Q]\nFor arbitrary C′ and R, we have a CPRHL-proof with open leaves of {Q[x 7→E]} x 7→E; C′ {R} as\nfollows:\n[Q] C′ [R]\n(:=CPRHL)\n[Q[x 7→E]] x 7→E; C′ [R]\n.\nThe only proper open leaf in this CPRHL-proof with open leaves is assigned {Q} C′ {R}, as required.\nCase(SeqRHL). In this case, C ≡C0; C1. Then, the proof of [P] C [Q] is the following:\n14\n\n\n[P] C0 [R′]\n[R′] C1 [Q] (SeqRHL)\n[P] C0; C1 [Q]\n.\nSince [P] C [R′] is provable in PRHL, induction hypothesis implies that, for any program C′′ and\nassertion R, there is a CPRHL-proof with open leaves of [P] C0; C′′ [R] such every open leaf is assigned\n[R′] C′′ [R]. Since C′′ is arbitrary, there is a CPRHL-proof with open leaves of [P] C0; C1; C′ [R] such\nthat every proper open leaf is assigned [R′] C1; C′ [R] for any program C′. (1)\nThen, since [R′] C1 [Q] is provable in PRHL, induction hypothesis implies that, for any program C′\nand assertion R, there is a CPRHL-proof with open leaves of [R′] C1; C′ [R] such that every proper\nopen leaf is assigned [Q] C′ [R]. (2)\nPutting (1) and (2) together gives us the CPRHL-proof with open leaves of [P] C0C1C′ [R] such that\nevery proper open leaf is assigned [Q] C′ [R] as follows:\n[Q] C′ [R]\n(2)\n[R′] C1; C′ [R]\n(1)\n[P] C0; C1 [Q]\n.\nCase(ConsRHL). In this case, the proof of [P] C [Q] is the following:\n[P ′] C [Q′]\n(P ′ |= P, Q |= Q′)\n(ConsRHL)\n[P] C [Q]\n.\nSince [P ′] C [Q′] is provable in PRHL, induction hypothesis implies that, for any program C′ and\nassertion R, there is a CPRHL-proof with open leaves of [P ′] C; C′ [R] such every open leaf is assigned\n[Q′] C′ [R].\nNow, for arbitrary C′ and R, we have a CPRHL-proof with open leaves of [P] C; C′ [R] as follows:\n[Q] C′ [R]\n(Q |= Q′)\n(ConsRHL)\n[Q′] C′ [R]\n(IH)\n[P ′] C; C′ [R]\n(P ′ |= P)\n(ConsRHL)\n[P] C; C′ [R]\n.\nThe proper open leaves in this CPRHL-proof with open leaves are assigned {Q} C′ {R}, as required.\nCase(OrPRHL). Assume that [P] either C0 or C1 ro [Q] is provable in Hoare logic with the following\nproof:\n[P] C0 [Q]\n[P] C1 [Q]\n(OrPRHL)\n[P] either C0 or C1 ro [Q]\n.\n15\n\n\nSince [P] Ci [Q] is provable in PRHL for i = 0, 1, induction hypothesis implies that, for any program\nC′ and assertion R, there is a CPRHL-proof with open leaves of [P] Ci; C′ [R] such every open leaf is\nassigned [Q] C′ [R] for i = 0, 1. We derive a CPRHL-proof with open leaves of [Q] C′ [R] as follows:\n[Q] C′ [R]\n(IH)\n[P] C0; C′ [Q]\n[Q] C′ [R]\n(IH)\n[P] C1; C′ [Q] (OrCPRHL)\n[P] either C0 or C1 ro; C′ [Q]\n.\nCase(WhilePRHL). In this case, C ≡while B do C0 od. Then, Q ≡¬B →P holds and the proof of\n[P] C [Q] is the following:\n[B →P] C0 [P]\n(WhilePRHL)\n[P] while B do C0 od [¬B →P]\n.\nSince [B →P] C0 [P] is provable in PRHL, the induction hypothesis implies that, for any program\nC′′ and assertion R, there is a CPRHL-proof with open leaves of [B →P] C0; C′′ [R] such that every\nproper open leaf is assigned [P] C′′ [R].\nSince C′′ is arbitrary, for any program C′ and assertion\nR, there is a CPRHL-proof with open leaves of [B →P] C0; while B do C0 od; C′ [R] such that every\nproper open leaf is assigned [P] while B do C0 od; C′ [R].\nWe derive a CPRHL-proof with open leaves of {P} while B do C0 od; C′ {R} as follows:\n[¬B →P] C′ [R]\n[P] while B do C0 od; C′ [R]\n(IH)\n[B →P] C; while B do C0 od; C′ [R] (WhileCPRHL)\n[P] while B do C0 od; C′ [R]\n.\nIn the CPRHL-proof with open leaves above, any occurrence of [P] while B do C0 od; C′ [R] as a leaf\nhas a back-link to the root. Then, each proper open leaf in the CPRHL-proof with open leaves above\nis assigned [¬B →P] C′ [R].\nNow, we show the completeness theorem.\nProof of Theorem 4.5. Fix [P] C [Q] be a partial reverse Hoare triple.\n(1)⇒(2): By Theorem 3.6.\n(2)⇒(3): Assume [P] C [Q] is provable in PRHL. By Lemma 4.7, there is a CPRHL-proof with open\nleaves of [P] C [Q] such that every proper open leaf is assigned [Q] ε [Q]. Since [Q] ε [Q] can be the\nconclusion of (AxiomRHL), there is a CPRHL-proof of [P] C [Q].\n(3)⇒(1): By Theorem 4.4.\n5. Conclusion\nWe have given ordinary and cyclic proof systems for partial reverse Hoare logic. Then, we have\nshown their soundness and relative completeness. Although the semantics of partial reverse Hoare\nlogic is the dual of “total” Hoare logic, assertions in the rule for the while loop are the dual of these\nin “partial” Hoare logic. Comparing cyclic proofs with ordinary proofs, we do not need to ﬁnd loop\ninvariants. This is an advantage of cyclic proofs for proof search.\n16\n\n\nWe wonder whether WPR-expressiveness is necessary for relative completeness. J. A. Bergstra\nand J. V. Tucker [6] showed that the expressiveness of the language of assertions, which means that\nthe language can express the weakest liberal pre-conditions for any assertion and any program, is\nnot necessary for the relative completeness of partial Hoare logic. We conjecture that a similar result\nholds in partial reverse Hoare logic.\nOther future work would be (1) to extend partial reverse Hoare logic, for example, by separation\nlogic, (2) to deﬁne cyclic proof systems for other Hoare-style logics, and (3) to study a method to\nﬁnd loop invariants from cyclic proofs.\nAcknowledgements\nWe would like to thank Quang Loc Le, James Brotherston, Koji Nakazawa, Daisuke Kimura, and\nTatsuya Abe for their valuable comments.\nReferences\n[1] Bahareh Afshari and Graham E. Leigh. Cut-free completeness for modal mu-calculus. In 32nd\nAnnual ACM/IEEE Symposium on Logic in Computer Science, LICS 2017, Reykjavik, Iceland,\nJune 20-23, 2017, pages 1–12. IEEE Computer Society, 2017.\n[2] Krzysztof R. Apt. Ten years of hoare’s logic: A survey - part 1. ACM Trans. Program. Lang.\nSyst., 3(4):431–483, 1981.\n[3] Krzysztof R. Apt and Ernst-R¨udiger Olderog.\nFifty years of hoare’s logic.\nFormal Aspects\nComput., 31(6):751–807, 2019.\n[4] Vytautas Astrauskas, Aurel B´ıl´y, Jon´as Fiala, Zachary Grannan, Christoph Matheja, Peter\nM¨uller, Federico Poli, and Alexander J. Summers. The prusti project: Formal veriﬁcation for\nrust.\nIn Jyotirmoy V. Deshmukh, Klaus Havelund, and Ivan Perez, editors, NASA Formal\nMethods - 14th International Symposium, NFM 2022, Pasadena, CA, USA, May 24-27, 2022,\nProceedings, volume 13260 of Lecture Notes in Computer Science, pages 88–108. Springer, 2022.\n[5] Stefano Berardi and Makoto Tatsuta. Classical system of martin-lof’s inductive deﬁnitions is\nnot equivalent to cyclic proofs. Log. Methods Comput. Sci., 15(3), 2019.\n[6] Jan A. Bergstra and John V. Tucker. Expressiveness and the completeness of hoare’s logic. J.\nComput. Syst. Sci., 25(3):267–284, 1982.\n[7] James Brotherston, Richard Bornat, and Cristiano Calcagno. Cyclic proofs of program termi-\nnation in separation logic. In Proceedings of POPL-35. ACM, 2008.\n[8] James Brotherston, Dino Distefano, and Rasmus Lerchedahl Petersen. Automated cyclic en-\ntailment proofs in separation logic. In Nikolaj S. Bjørner and Viorica Sofronie-Stokkermans,\neditors, Automated Deduction - CADE-23 - 23rd International Conference on Automated De-\nduction, Wroclaw, Poland, July 31 - August 5, 2011. Proceedings, volume 6803 of Lecture Notes\nin Computer Science, pages 131–146. Springer, 2011.\n[9] James Brotherston and Nikos Gorogiannis. Cyclic abduction of inductively deﬁned safety and\ntermination preconditions. In Markus M¨uller-Olm and Helmut Seidl, editors, Static Analysis -\n21st International Symposium, SAS 2014, Munich, Germany, September 11-13, 2014. Proceed-\nings, volume 8723 of Lecture Notes in Computer Science, pages 68–84. Springer, 2014.\n17\n\n\n[10] James Brotherston, Nikos Gorogiannis, and Rasmus Lerchedahl Petersen. A generic cyclic theo-\nrem prover. In Ranjit Jhala and Atsushi Igarashi, editors, Programming Languages and Systems\n- 10th Asian Symposium, APLAS 2012, Kyoto, Japan, December 11-13, 2012. Proceedings, vol-\nume 7705 of Lecture Notes in Computer Science, pages 350–367. Springer, 2012.\n[11] James Brotherston and Alex Simpson. Sequent calculi for induction and inﬁnite descent. J. Log.\nComput., 21(6):1177–1216, 2011.\n[12] Cristiano Calcagno and Dino Distefano. Infer: An automatic program veriﬁer for memory safety\nof C programs. In Mihaela Gheorghiu Bobaru, Klaus Havelund, Gerard J. Holzmann, and Rajeev\nJoshi, editors, NASA Formal Methods - Third International Symposium, NFM 2011, Pasadena,\nCA, USA, April 18-20, 2011. Proceedings, volume 6617 of Lecture Notes in Computer Science,\npages 459–465. Springer, 2011.\n[13] Duc-Hiep Chu, Joxan Jaﬀar, and Minh-Thai Trinh.\nAutomatic induction proofs of data-\nstructures in imperative programs. In David Grove and Stephen M. Blackburn, editors, Pro-\nceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Imple-\nmentation, Portland, OR, USA, June 15-17, 2015, pages 457–466. ACM, 2015.\n[14] Stephen A. Cook. Soundness and completeness of an axiom system for program veriﬁcation.\nSIAM J. Comput., 7(1):70–90, 1978.\n[15] Anupam Das. On the logical complexity of cyclic arithmetic. Log. Methods Comput. Sci., 16(1),\n2020.\n[16] Edsko de Vries and Vasileios Koutavas. Reverse hoare logic. In Gilles Barthe, Alberto Pardo,\nand Gerardo Schneider, editors, Software Engineering and Formal Methods - 9th International\nConference, SEFM 2011, Montevideo, Uruguay, November 14-18, 2011. Proceedings, volume\n7041 of Lecture Notes in Computer Science, pages 155–171. Springer, 2011.\n[17] Carlo A. Furia, Bertrand Meyer, and Sergey Velder. Loop invariants: Analysis, classiﬁcation,\nand examples. ACM Comput. Surv., 46(3):34:1–34:51, 2014.\n[18] C. A. R. Hoare. An axiomatic basis for computer programming. Commun. ACM, 12(10):576–\n580, 1969.\n[19] Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal,\nand Derek Dreyer.\nIris: Monoids and invariants as an orthogonal basis for concurrent rea-\nsoning. In Sriram K. Rajamani and David Walker, editors, Proceedings of the 42nd Annual\nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2015,\nMumbai, India, January 15-17, 2015, pages 637–650. ACM, 2015.\n[20] Daisuke Kimura, Koji Nakazawa, Tachio Terauchi, and Hiroshi Unno. Failure of cut-elimination\nin cyclic proofs of separation logic. Computer Software, 37(1):39–52, 2020.\n[21] Yeonseok Lee and Koji Nakazawa. Relative completeness of incorrectness separation logic. In\nOleg Kiselyov, editor, Programming Languages and Systems - 22nd Asian Symposium, APLAS\n2024, Kyoto, Japan, October 22-24, 2024, Proceedings, volume 15194 of Lecture Notes in Com-\nputer Science, pages 264–282. Springer, 2024.\n[22] Zohar Manna and Amir Pnueli. Axiomatic approach to total correctness of programs. Acta\nInformatica, 3:243–263, 1974.\n18\n\n\n[23] Yukihiro Oda, James Brotherston, and Makoto Tatsuta. The failure of cut-elimination in cyclic\nproof for ﬁrst-order logic with inductive deﬁnitions. Journal of Logic and Computation, page\nexad068, 12 2023.\n[24] Peter W. O’Hearn. Incorrectness logic. Proc. ACM Program. Lang., 4(POPL), dec 2019.\n[25] Peter W. O’Hearn, John C. Reynolds, and Hongseok Yang. Local reasoning about programs that\nalter data structures. In Laurent Fribourg, editor, Computer Science Logic, 15th International\nWorkshop, CSL 2001. 10th Annual Conference of the EACSL, Paris, France, September 10-13,\n2001, Proceedings, volume 2142 of Lecture Notes in Computer Science, pages 1–19. Springer,\n2001.\n[26] Azalea Raad, Josh Berdine, Hoang-Hai Dang, Derek Dreyer, Peter W. O’Hearn, and Jules Vil-\nlard. Local reasoning about the presence of bugs: Incorrectness separation logic. In Shuvendu K.\nLahiri and Chao Wang, editors, Computer Aided Veriﬁcation - 32nd International Conference,\nCAV 2020, Los Angeles, CA, USA, July 21-24, 2020, Proceedings, Part II, volume 12225 of\nLecture Notes in Computer Science, pages 225–252. Springer, 2020.\n[27] Azalea Raad, Josh Berdine, Derek Dreyer, and Peter W. O’Hearn. Concurrent incorrectness\nseparation logic. Proc. ACM Program. Lang., 6(POPL):1–29, 2022.\n[28] John C. Reynolds.\nSeparation logic: A logic for shared mutable data structures.\nIn 17th\nIEEE Symposium on Logic in Computer Science (LICS 2002), 22-25 July 2002, Copenhagen,\nDenmark, Proceedings, pages 55–74. IEEE Computer Society, 2002.\n[29] Reuben N. S. Rowe. Non-well-founded and cyclic proof theory a bibliography, February 2024.\n[30] Reuben N. S. Rowe and James Brotherston. Automatic cyclic termination proofs for recursive\nprocedures in separation logic. In Yves Bertot and Viktor Vafeiadis, editors, Proceedings of the\n6th ACM SIGPLAN Conference on Certiﬁed Programs and Proofs, CPP 2017, Paris, France,\nJanuary 16-17, 2017, pages 53–65. ACM, 2017.\n[31] Kenji Saotome, Koji Nakazawa, and Daisuke Kimura. Restriction on Cut in Cyclic Proof System\nfor Symbolic Heaps. In Keisuke Nakano and Konstantinos Sagonas, editors, Functional and Logic\nProgramming, pages 88–105. Springer International Publishing, 2020.\n[32] Kenji Saotome, Koji Nakazawa, and Daisuke Kimura. Restriction on cut rule in cyclic-proof\nsystem for symbolic heaps. Theor. Comput. Sci., 1019:114854, 2024.\n[33] Daniyar Salkarbekovich Shamkanov. Circular proofs for the G¨odel-L¨ob provability logic. Math-\nematical Notes, 96(3-4):575–585, 2014.\n[34] Alex Simpson.\nCyclic arithmetic is equivalent to peano arithmetic.\nIn Javier Esparza and\nAndrzej S. Murawski, editors, Foundations of Software Science and Computation Structures -\n20th International Conference, FOSSACS 2017, Held as Part of the European Joint Confer-\nences on Theory and Practice of Software, ETAPS 2017, Uppsala, Sweden, April 22-29, 2017,\nProceedings, volume 10203 of Lecture Notes in Computer Science, pages 283–300, 2017.\n[35] Quang-Trung Ta, Ton Chanh Le, Siau-Cheng Khoo, and Wei-Ngan Chin. Automated mutual\nexplicit induction proof in separation logic. In John S. Fitzgerald, Constance L. Heitmeyer,\nStefania Gnesi, and Anna Philippou, editors, FM 2016: Formal Methods - 21st International\nSymposium, Limassol, Cyprus, November 9-11, 2016, Proceedings, volume 9995 of Lecture Notes\nin Computer Science, pages 659–676, 2016.\n19\n\n\n[36] Quang-Trung Ta, Ton Chanh Le, Siau-Cheng Khoo, and Wei-Ngan Chin. Automated lemma\nsynthesis in symbolic-heap separation logic.\nProc. ACM Program. Lang., 2(POPL):9:1–9:29,\n2018.\n[37] Makoto Tatsuta, Koji Nakazawa, and Daisuke Kimura. Completeness of Cyclic Proofs for Sym-\nbolic Heaps with Inductive Deﬁnitions. In Anthony Widjaja Lin, editor, Programming Languages\nand Systems, pages 367–387. Springer International Publishing, 2019.\n[38] Gadi Tellez and James Brotherston.\nAutomatically verifying temporal properties of pointer\nprograms with cyclic proof. J. Autom. Reason., 64(3):555–578, 2020.\n[39] Takeshi Tsukada and Hiroshi Unno. Software model-checking as cyclic-proof search. Proc. ACM\nProgram. Lang., 6(POPL):1–29, 2022.\n[40] Hiroshi Unno, Sho Torii, and Hiroki Sakamoto. Automating induction for solving horn clauses. In\nRupak Majumdar and Viktor Kuncak, editors, Computer Aided Veriﬁcation - 29th International\nConference, CAV 2017, Heidelberg, Germany, July 24-28, 2017, Proceedings, Part II, volume\n10427 of Lecture Notes in Computer Science, pages 571–591. Springer, 2017.\n[41] Lena Verscht and Benjamin Lucien Kaminski.\nA taxonomy of hoare-like logics: Towards a\nholistic view using predicate transformers and kleene algebras with top and tests. Proc. ACM\nProgram. Lang., 9(POPL):1782–1811, 2025.\n[42] Lena Verscht, ¯Anr´an W´ang, and Benjamin Lucien Kaminski. Partial incorrectness logic, 2025.\n[43] Glynn Winskel. The formal semantics of programming languages - an introduction. Foundation\nof computing series. MIT Press, 1993.\n[44] Linpeng Zhang and Benjamin Lucien Kaminski. Quantitative strongest post: a calculus for\nreasoning about the ﬂow of quantitative information. Proc. ACM Program. Lang., 6(OOPSLA1),\napr 2022.\nA. Construction of weakest pre-condition assertion\nWe construct a weakest pre-condition assertion wpr(C, Q). In this appendix, we assume that our\nlanguage includes addition operator +, subtraction operator −, multiplication operator ∗, division\noperator /, and reminder operator %.\nWe abbreviate x = a%(1 + (1 + i) ∗b) to β(a, b, i, x). It is so-called G¨odel’s predicate β [43]. For\nG¨odel’s predicate β, the following statement holds.\nFact A.1. For any ﬁnite sequence of natural numbers a0, . . . , ak, and any natural number j (0 ≤j ≤\nk), there exists two natural numbers n and m such that x = aj holds if and only if β(n, m, j, x) holds.\nThe above fact means that any ﬁnite sequence of natural numbers can be encoded as two natural\nnumbers n and m.\nDeﬁnition A.2 (Weakest pre-condition assertion). For an assertion P and a program C, we induc-\ntively deﬁne an assertion wpr(C, Q) in Figure 4.\nProposition A.3. σ ∈WPR(C, Q) if and only if σ |= wpr(C, Q) for any state σ.\nProof. We show the statement by induction on construction of C. We consider cases according to\nthe form of C.\nCase(C ≡ε). In this case, wpr(C, Q) ≡Q.\nIf σ ∈WPR(C, Q), then we have σ |= Q ≡wpr(C, Q).\n20\n\n\nwpr(ε, Q) ≡Q\nwpr(x := E, Q) ≡Q[x 7→E]\nwpr(C1; C2, Q) ≡wpr(C1, wpr(C2, Q))\nwpr(either C1 or C2 ro, Q) ≡wpr(C1, Q) ∨wpr(C2, Q)\nwpr(while B do C od, Q) ≡∃k∃m∃n∀y1 . . . ∀yl∀y′\n1 . . . ∀y′\nl∀y′′\n1 . . . ∀y′′\nl ∀y′′′\n1 . . . ∀y′′′\nl\n(Fl(n, m) ∧Sl\n\u0000k, m, n, y1, . . . , yl, y′\n1, . . . , y′\nl, y′′\n1, . . . , y′′\nl , B, C\n\u0001\n∧Tl\n\u0000k, m, n, y′′′\n1 , . . . , y′′′\nl , B, Q\n\u0001\n),\nwhere FV(P) ∪Var(while B do C od) = {x1, . . . , xl},\nFl(n, m) ≡(β(n, m, 0, x1) ∧· · · ∧β(n, m, l −1, xl)),\nSl\n\u0000k, m, n, y′\n1, . . . , y′\nl, y′′\n1, . . . , y′′\nl , y′′′\n1 , . . . , y′′′\nl , B, C\n\u0001\n≡(0 < k →(∀i((0 ≤i ∧i < k) →\n(β(n, m, l ∗i, y1) ∧· · · ∧β(n, m, l ∗(i + 1) −1, yl))∧\n(β\n\u0000n, m, l ∗(i + 1), y′\n1\n\u0001\n∧· · · ∧β\n\u0000n, m, l ∗(i + 2) −1, y′\nl\n\u0001\n)\n→(B[x1 7→y1, . . . , xl 7→yl]∧\n(wpr\n\u0000C, x1 = y′\n1 ∧· · · ∧xl = y′\nl\n\u0001\n→(x1 = y1 ∧· · · ∧xl = yl))\n\u0002\nx1 7→y′′\n1, . . . , xl 7→y′′\nl\n\u0003\n)))),\nand\nTl\n\u0000k, m, n, y′′′\n1 , . . . , y′′′\nl , B, Q\n\u0001\n≡(β\n\u0000n, m, l ∗k, y′′′\n1\n\u0001\n∧· · · ∧β\n\u0000n, m, l ∗(k + 1) −1, y′′′\nl\n\u0001\n→\n((¬ B\n\u0002\nx1 7→y′′′\n1 , . . . , xl 7→y′′′\nl\n\u0003\n)∧\n(Q\n\u0002\nx1 7→y′′′\n1 , . . . , xl 7→y′′′\nl\n\u0003\n)))\nFigure 4: Weakest pre-condition\nAssume σ |= wpr(C, Q) ≡Q.\nThen, we have ⟨ε, σ⟩−→∗⟨ε, σ⟩and σ |= Q.\nWe have σ ∈\nWPR(C, Q).\nCase(C ≡x := E). In this case, wpr(C, Q) ≡Q[x 7→E].\nAssume σ ∈WPR(C, Q). Then, we have ⟨x := E, σ⟩−→⟨ε, σ[x 7→[[E]]σ]⟩and σ[x 7→[[E]]σ] |= Q.\nBy Lemma 2.2, σ |= Q[x 7→E] holds. Hence, we have σ |= wpr(C, Q).\nAssume σ |= wpr(C, Q) ≡Q[x 7→E]. Then, we have ⟨x := E, σ⟩−→⟨ε, σ[x 7→[[E]]σ]⟩and σ[x 7→[[E]]σ] |= Q.\nThus, σ ∈WPR(C, Q) holds.\nCase(C ≡C1; C2). In this case, wpr(C, Q) ≡wpr(C1, wpr(C2, Q)).\nAssume σ ∈WPR(C, Q).\nThen, there exists a state σ′ such that ⟨C1; C2, σ⟩−→∗⟨ε, σ′⟩and\nσ′ |= Q hold. By Lemma 2.3 (3), there exists σ′′ such that ⟨C1, σ⟩−→∗⟨ε, σ′′⟩and ⟨C2, σ′′⟩−→∗\n⟨ε, σ′⟩hold. Since ⟨C2, σ′′⟩−→∗⟨ε, σ′⟩and σ′ |= Q hold, we have σ′′ ∈WPR(C2, Q). By induction\nhypothesis, we have σ′′ |= wpr(C2, Q). Because of ⟨C1, σ⟩−→∗⟨ε, σ′′⟩, we see σ ∈WPR(C1, wpr(C2, Q)).\nBy induction hypothesis, we have σ |= wpr(C1, wpr(C2, Q)).\nAssume σ |= wpr(C, Q).\nThen, we have σ |= wpr(C1, wpr(C2, Q)).\nBy induction hypothesis,\nwe have σ ∈WPR(C1, wpr(C2, Q)).\nHence, there exists σ′′ such that ⟨C1, σ⟩−→∗⟨ε, σ′′⟩and\nσ′′ |= wpr(C2, Q) hold. By induction hypothesis, we have σ′′ ∈WPR(C2, Q). Therefore, there exists\na state σ′ such that ⟨C2, σ′′⟩−→∗⟨ε, σ′⟩and σ′ |= Q. By Lemma 2.3 (3), ⟨C1; C2, σ⟩−→∗⟨ε, σ′⟩\nholds. Thus, σ ∈WPR(C, Q) holds.\n21\n\n\nCase(C ≡either C1 or C2 ro). In this case, wpr(C, Q) ≡wpr(C1, Q) ∨wpr(C2, Q).\nAssume σ ∈WPR(C, Q). Then, there exists a state σ′ such that ⟨either C1 or C2 ro, σ⟩−→∗⟨ε, σ′⟩\nand σ′ |= Q hold. We see either ⟨either C0 or C1 ro, σ⟩−→⟨C0, σ⟩−→∗⟨ε, σ′⟩or ⟨either C0 or C1 ro, σ⟩−→\n⟨C1, σ⟩−→∗⟨ε, σ′⟩holds. Then, we have either σ ∈WPR(C0, Q) or σ |= WPR(C1, Q). By induc-\ntion hypothesis, we have either σ |= wpr(C0, Q) or σ |= wpr(C1, Q). Thus, σ |= wpr(C0, Q) ∨wpr(C1, Q) ≡\nwpr(C, Q) holds.\nAssume σ |= wpr(C, Q). Then, σ |= wpr(C0, Q) ∨wpr(C1, Q). We have σ |= wpr(C0, Q) or σ |=\nwpr(C1, Q) holds. By induction hypothesis, we have either σ ∈WPR(C0, Q) or σ |= WPR(C1, Q).\nAssume σ ∈WPR(C0, Q). Then, there exists a state σ′ such that ⟨C0, σ⟩−→∗⟨ε, σ′⟩and σ′ |= Q\nhold.\nBecause ⟨either C0 or C1 ro, σ⟩−→⟨C0, σ⟩holds, we have ⟨either C0 or C1 ro, σ⟩−→∗\n⟨ε, σ′⟩. Hence, we have σ ∈WPR(either C0 or C1 ro, Q).\nIn the similar way, we have σ ∈WPR(either C0 or C1 ro, Q) if σ ∈WPR(C1, Q) holds.\nThus, σ ∈WPR(C, Q) holds.\nCase(C ≡while B do C0 od). Let FV(P) ∪Var(while B do C od) = {x1, . . . , xl}.\nAssume σ ∈WPR(C, Q). Then, there exists a state σ′ such that ⟨while B do C0 od, σ⟩−→∗⟨ε, σ′⟩\nand σ′ |= Q hold.\nBy Lemma 2.3 (4), there exist states σ0, . . . , σk such that σ0 ≡σ, σk ≡σ′,\nσk |= ¬B hold, and k > 0 implies that ⟨C, σi⟩−→∗⟨ε, σi+1⟩and σi |= B for each i = 0, . . . , k −1.\nLet s(i∗l)+(j−1) = σi(xj) for each i = 0, . . . , k and each j = 1, . . . , l. By Fact A.1, (sh)0≤h≤k∗(l+1)−1\ncan be encoded as two natural numbers n and m. Then,\nσ |= (β(n, m, 0, x1) ∧· · · ∧β(n, m, l −1, xl))\nholds.\nAssume k > 0. For each i = 0, . . . , k −1,\n|= (β(n, m, l ∗i, y1) ∧· · · ∧β(n, m, l ∗(i + 1) −1, yl)) →(B[x1 7→y1, . . . , xl 7→yl])\nand\n|= (β(n, m, l ∗i, y1) ∧· · · ∧β(n, m, l ∗(i + 1) −1, yl))∧\n(β\n\u0000n, m, l ∗(i + 1), y′\n1\n\u0001\n∧· · · ∧β\n\u0000n, m, l ∗(i + 2) −1, y′\nl\n\u0001\n) →\n(wpr\n\u0000C, x1 = y′\n1 ∧· · · ∧xl = y′\nl\n\u0001\n→\n(x1 = y1 ∧· · · ∧xl = yl))\n\u0002\nx1 7→y′′\n1, . . . , xl 7→y′′\nl\n\u0003\n. Hence,\n|= Sl\n\u0000k, m, n, y′\n1, . . . , y′\nl, y′′\n1, . . . , y′′\nl , y′′′\n1 , . . . , y′′′\nl , B, C\n\u0001\nBy σk |= ¬B and σk |= Q, we have\n|= (β\n\u0000n, m, l ∗k, y′′′\n1\n\u0001\n∧· · · ∧β\n\u0000n, m, l ∗(k + 1) −1, y′′′\nl\n\u0001\n→\n((¬ B\n\u0002\nx1 7→y′′′\n1 , . . . , xl 7→y′′′\nl\n\u0003\n)∧\n(Q\n\u0002\nx1 7→y′′′\n1 , . . . , xl 7→y′′′\nl\n\u0003\n))).\nThus,\nσ |= ∃k∃m∃n∀y1 . . . ∀yl∀y′\n1 . . . ∀y′\nl∀y′′\n1 . . . ∀y′′\nl ∀y′′′\n1 . . . ∀y′′′\nl\n(Fl(n, m) ∧Sl\n\u0000k, m, n, y1, . . . , yl, y′\n1, . . . , y′\nl, y′′\n1, . . . , y′′\nl , B, C\n\u0001\n∧\nTl\n\u0000k, m, n, y′′′\n1 , . . . , y′′′\nl , B, Q\n\u0001\n)\n22\n\n\nAssume σ |= wpr(C, Q). Then, there exist natural numbers ¯k, ¯m and ¯n such that\nσ\n\"k 7→¯k, m 7→¯m, n 7→¯n,\n−→y 7→−→c ,\n−→\ny′ 7→\n−→\nc′ ,\n−→\ny′′ 7→\n−→\nc′′,\n−→\ny′′′ 7→\n−→\nc′′′\n#\n|= Fl(n, m),\n(3)\nσ\n\"k 7→¯k, m 7→¯m, n 7→¯n,\n−→y 7→−→c ,\n−→\ny′ 7→\n−→\nc′ ,\n−→\ny′′ 7→\n−→\nc′′,\n−→\ny′′′ 7→\n−→\nc′′′\n#\n|= Sl\n\u0000k, m, n, y1, . . . , yl, y′\n1, . . . , y′\nl, y′′\n1, . . . , y′′\nl , B, C0\n\u0001\n,\n(4)\nand\nσ\n\"k 7→¯k, m 7→¯m, n 7→¯n,\n−→y 7→−→c ,\n−→\ny′ 7→\n−→\nc′ ,\n−→\ny′′ 7→\n−→\nc′′,\n−→\ny′′′ 7→\n−→\nc′′′\n#\n|= Tl\n\u0000k, m, n, y′′′\n1 , . . . , y′′′\nl , B, Q\n\u0001\n,\n(5)\nwhere −→y 7→−→c ≡y1 7→c1, . . . , yl 7→cl, −→\ny′ 7→−→\nc′ ≡y′\n1 7→c′\n1, . . . , y′\nl 7→c′\nl, −→\ny′′ 7→−→\nc′′ ≡y′′\n1 7→c′′\n1, . . . , y′′\nl 7→c′′\nl ,\nand −→\ny′′′ 7→−→\nc′′′ ≡y′′′\n1 7→c′′′\n1 , . . . , y′′′\nl 7→c′′′\nl , for all natural numbers c1, . . . , cl, c′\n1, . . . , c′\nl, c′′\n1, . . . , c′′\nl , c′′′\n1 , . . . , c′′′\nl .\nBy Fact A.1, two natural numbers n and m encode some ﬁnite sequence of natural numbers (sh)0≤h≤.\nBy (3) and FV(P) = {x1, . . . , xl}, we have\nσ |= (β(n, m, 0, x1) ∧· · · ∧β(n, m, l −1, xl)).\nBy (4),\nσ |= wpr\n\u0000C0, x1 = si∗l ∧· · · ∧xl = si∗(l+1)−1\n\u0001h−→x 7→\n−→\nc′′i\n→(c′′\n1 = si∗(l+1) ∧· · · ∧c′′\nl = si∗(l+2)−1),\n(6)\nwhere −→x 7→−→\nc′′ ≡x1 7→c′′\n1, . . . , xl 7→c′′\nl , for each i = 0, . . . , ¯k −1. By (5), we have\nσ |= ¬ B\nh\nx1 7→sl∗¯k, . . . , xl 7→sl∗(¯k+1)−1\ni\n∧Q\nh\nx1 7→sl∗¯k, . . . , xl 7→sl∗(¯k+1)−1\ni\n.\nLet σi be a state for i = 0, . . . , ¯k, where σi(xj) = si∗l+j−1. Then, σ0 ≡σ, σk ≡σ′, and σk |= ¬B hold.\nBy (6), we have ⟨C0, σi⟩−→∗⟨ε, σi+1⟩, and σi |= B hold for each i = 0, . . . , ¯k −1. By Lemma 2.3\n(4), ⟨while B do C0 od, σ⟩−→∗⟨ε, σk⟩hold. Because of σk |= Q, we have σ ∈WPR(C, Q).\n23\n\n\n",
  "metadata": {
    "source_file": "dataset/pdfs/arxiv_2502.21053v1.pdf",
    "total_pages": 23,
    "title": "Proof systems for partial incorrectness logic (partial reverse Hoare logic)",
    "authors": [
      "Yukihiro Oda"
    ],
    "abstract": "Partial incorrectness logic (partial reverse Hoare logic) has recently been\nintroduced as a new Hoare-style logic that over-approximates the weakest\npre-conditions of a program and a post-condition. It is expected to verify\nsystems where the final state must guarantee its initial state, such as\nauthentication, secure communication tools and digital signatures. However, the\nlogic has only been given semantics. This paper defines two proof systems for\npartial incorrectness logic (partial reverse Hoare logic): ordinary and cyclic\nproof systems. They are sound and relatively complete. The relative\ncompleteness of our ordinary proof system is proved by showing that the weakest\npre-condition of a while loop and a post-condition is its loop invariant. The\nrelative completeness of our cyclic proof system is also proved by providing a\nway to transform any cyclic proof into an ordinary proof.",
    "published_date": "2025-02-28",
    "source": "arxiv"
  }
}