{
  "id": "arxiv_2502.21101v1",
  "text": "Jointly Assigning Processes to Machines and Generating Plans for\nAutonomous Mobile Robots in a Smart Factory\nChistopher Leet1, Aidan Sciortino2, Sven Koenig3\nAbstract— A modern smart factory runs a manufacturing\nprocedure using a collection of programmable machines. Typi-\ncally, materials are ferried between these machines using a team\nof mobile robots. To embed a manufacturing procedure in a\nsmart factory, a factory operator must a) assign its processes\nto the smart factory’s machines and b) determine how agents\nshould carry materials between machines. A good embedding\nmaximizes the smart factory’s throughput; the rate at which it\noutputs products. Existing smart factory management systems\nsolve the aforementioned problems sequentially, limiting the\nthroughput that they can achieve. In this paper we introduce\nACES, the Anytime Cyclic Embedding Solver, the first solver\nwhich jointly optimizes the assignment of processes to machines\nand the assignment of paths to agents. We evaluate ACES and\nshow that it can scale to real industrial scenarios.\nI. INTRODUCTION\nModern smart factories are designed to enable flexible\nmanufacturing [1]. A flexible manufacturing system is a\nsystem which can produce a variety of different products\nwith minimal reconfiguration [2]. Flexibility can improve a\nmanufacturer’s ability to customize products, reduce the time\nthat it takes to fulfill new orders, and lower the costs of\nproducing a new product. Today, a wide range of industries\npractice flexible manufacturing, including the automotive,\nmedical, and textile industries [3].\nTo permit flexible manufacturing, a smart factory needs\nthe following two components:\n1) Flexible Machines. Flexible machines are general-purpose\nmachines such as CNC machines which can be programmed\nto carry out a range of manufacturing processes [4]. Their\nprogrammability makes it easy to change the process as-\nsigned to each machine when the product produced by the\nsmart factory changes. Their programmability also makes it\neasy to relieve bottlenecks in a manufacturing procedure by\nchanging the number of machines assigned to its processes.\n2) Flexible Transport System. A flexible transport system\nmakes it easy to adjust the flow of parts through a smart\nfactory when the product produced by the smart factory\nchanges. Typically, flexible transport systems use a team of\nagents to ferry parts between machines [5]. In a traditional\nsmart factory, agents are autonomous mobile robots [5].\nIn a mag-lev based smart factory, such as BOSCH’s ctrlX\nFlow6D [6], agents are magnetically levitating shuttles. With\nsuch a system, adjusting the flow of parts between machines\nis as simple as adjusting the circulation of agents through\nthe factory.\n1University of Southern California, cjleet@usc.edu\n2University of Rochester asciorti@u.rochester.edu\n3University of Southern California, skoenig@usc.edu\nTo embed a manufacturing procedure into a smart factory,\na factory operator needs to:\n1) assign the processes in the manufacturing procedure to\nthe smart factory’s machines.\n2) find a transport plan which specifies how the smart fac-\ntory’s agents should ferry materials between machines.\nWe term the problem of embedding a manufacturing pro-\ncedure into a smart factory the Smart Factory Embedding\nProblem (SFEP). A good embedding maximizes a smart\nfactory’s throughput, the rate at which it outputs products.\nTo date, the SFEP is open. To our knowledge, no existing\nsmart factory management system [7], [8] jointly optimizes\nthe assignment of processes to machines and paths to agents.\nSolving these problems separately limits the overall through-\nput that these systems achieve.\nIn this paper, we address this lacuna. First, we present\nthe first formal model of the SFEP as a combinatorial opti-\nmization problem. We then solve the SFEP by introducing\nACES, the Anytime Cyclic Embedding Solver. ACES models\nthe SFEP as a mixed-integer linear program (MILP). Na¨ıvely\nmodeling the SFEP as a MILP does not generate a practical\nsolution. Multi-Agent Path Finding (MAPF), the problem\nof finding collision-free paths for a team of agents, is an\nimportant component of the SFEP. MILP-based solutions to\nMAPF often struggle to scale [9], limiting their applicability\nto industry. ACES addresses this problem as follows.\nACES generates cyclic transport plans. A cyclic transport\nplan starts and ends with its team of agents in the same state.\nAs a result, it can be looped indefinitely. Fixing the length of\na cyclic transport plan limits the number of decision variables\nrequired to generate it. Decreasing the number of decision\nvariables in a MILP decreases its difficulty. ACES generates\ncyclic transport plans with incrementally longer loop lengths.\nThe more time that ACES is given, the more loop lengths it\nconsiders and the better the throughput of its best plan.\nACES represents the parts being ferried between machines\nas tokens. ACES considers a variant of the SFEP where these\ntokens are modelled as “agent-tokens”, abstract agents which\nmove between machines under their own power. Two agent-\ntokens which represent the same part are indistinguishable.\nFinding a plan for a team of largely indistinguishable agent-\ntokens requires fewer decision variables than finding a plan\nfor a team of regular agents. A transport plan for token agents\ncan be converted into a transport plan for regular agents in\nlinear time. We evaluate ACES on 6 industrial scenarios and\nshow that it can be applied to real instances of the SFEP.\narXiv:2502.21101v1  [cs.RO]  28 Feb 2025\n\n\nFig. 1.\n(left) An example manufacturing procedure. Source process are yellow; sink processes blue. (right) An example smart factory.\nII. PROBLEM FORMULATION\nA. Manufacturing Procedure\nToken. Each raw material, part or assemblage produced or\nconsumed during a manufacturing procedure is modelled\nas a token. We denote the set of tokens associated with a\nmanufacturing procedure Z := {z1, z2, . . .}.\nProcess. A process pi is an atomic operation in a manufac-\nturing procedure. A process transforms a multiset of input\ntokens in(pi) into a multiset of output tokens out(pi). We\ndenote the number of copies of token zj ∈Z that a process\npi consumes and emits inj(pi) and outj(pi) respectively.\nProcesses which does not consume tokens are source\nprocesses. They represent operations which retrieve raw\nmaterials. Processes which does not emit tokens are sink\nprocesses. They represent operations which export finished\nproducts or remove waste. We denote a manufacturing pro-\ncedure’s set of processes P := {p1, p2, . . .}. Exactly one of\nthese processes must be an output process OUT(P), a sink\nprocess which exports finished products.\nManufacturing\nProcedure.\nA\nmanufacturing\nprocedure\n(Z, P, OUT(P)) is a set of processes P which consume and\nemit tokens from the set Z. It has the output process OUT(P).\nExample. Fig. 1. (left) depicts a manufacturing procedure that\nmakes toy cars. It has two source processes: p1 and p4. Its\noutput process is p6. Process p2 consumes 1 plank token zp\nand emits 1 frame token zf. Arrows show the flow of tokens\nthrough the manufacturing procedure.\nB. Smart Factory\nMachines. A smart factory contains a set of machines M :=\n{m1, m2, . . .}. Each machine mi ∈M can run a subset\nP(mi) of the processes in P. Time is discretized. The\nnumber of timesteps that machine mi takes to run a process\npj ∈P(mi) is denoted RUNTIME(mi, pj) ∈N.\nA machine has an input and an output buffer. When a\nmachine starts to run a process pj, it consumes the multiset\nof tokens in(pj) from its input buffer. If its input buffer does\nnot contain these tokens, it cannot run process pj. When it\nfinishes pj, it emits the multiset of tokens out(pj) into its\noutput buffer. At timestep t, machine mi’s input and output\nbuffers contain the multisets of tokens I(mi, t) and O(mi, t).\nLayout. We model a factory layout as a 4-connected grid\nof cells. A cell is traversable if an agent can enter it\nand non-traversable if it contains an obstacle such as a\nmachine chassis. The set of traversable cells is denoted\nC := {c1, c2, . . .}.\nAny machine which can run a process that consumes\ntokens has an input cell Cin(mi). Any machine which can\nMachine Type\nInstances\nSupported Processes\nBin of Planks\nm1\np1\nCNC Machine\nm2, m3, m4\np2, p3\nAssembler\nm5\np5\nBin of Axles\nm6\np4\nOutput Chute\nm7\np6\nTABLE I\nTHE MACHINES IN THE EXAMPLE SMART FACTORY.\nrun a process that emits tokens has an output cell Cout(mi).\nWe denote the set of all input and output cells Cin and Cout.\nTokens can only be placed in a machine’s input buffer from\nits input cell and and removed from a machine’s and output\nbuffer from its output cell. A machine’s input and output\ncells must be traversable. All input and output cells must be\ndistinct. A machine without an input cell is a source machine.\nSource machines only run source processes. They represent\nbins of raw materials. A machine without an output cell is a\nsink machine. Sink machines only run sink processes. They\nrepresent output chutes and waste bins.\nExample. Fig. 1. (right) depicts a smart factory. Machine m2\nhas the inlet and outlet cell (1, 2) and (2, 2). Table I describes\nits machines and lists the processes that they can run. There\nare two source machines: m1, a bin of planks, and m5, a bin\nof axles, and one sink machine: m6, an output chute.\nC. Agents\nTokens are carried between machines by a team of agents\nA := {a1, . . . an}. At the start of a timestep t, an agent ai\noccupies a traversable cell. We denote this cell π(ai, t). Each\ntimestep, an agent must wait at its current cell or move to a\ntraversable cell which shares an edge with its current cell.\nWe represent the actions that an agent can take at each cell\nwith an undirected graph called the movement graph G :=\n(C, E). Each vertex in this graph is a traversible cell. There\nis an edge (ci, cj) ∈E between two cells ci, cj ∈C × C iff\nan agent at cell ci can be at cell cj on the following timestep.\nConsequently, each traversible cell ci is connected to itself\nby a loop edge and to any traversible cell it shares a side\nwith. Two agents may not occupy the same cell or traverse\nthe same edge in the movement graph on the same timestep.\nAn agent can carry a single token. We term the token that\nan agent ai is carrying on timestep t its cargo and denote it\nσ(ai, t). If agent ai is not carrying a token on timestep t, its\ncargo is the null token z0. The set of all tokens that an agent\ncan carry Z∪{z0} is denoted Z0. The state (π(ai, t), σ(ai, t))\nof agent ai on timestep t is its location and its cargo.\nAn agent with a (non-null) token on a machine’s input\ncell may deposit its token into the machine’s input buffer.\nAn agent without a (non-null) token on a machine’s output\ncell may pick up a token from the machine’s output buffer.\n\n\nPicking up and depositing a token takes a single timestep.\nAn agent cannot move during this timestep.\nD. Embedding\nAn embedding describes how a manufacturing procedure\nis implemented by a smart factory. An embedding is a 6-tuple\n(A, R, I, O, π, σ) with the following components:\nAssignment Matrix. The assignment matrix A is an |M| ×\nP| matrix. The field A(mi, pj) ∈{0, 1} contains a binary\nvariable which indicates iff machine mi has been assigned\nprocess pj. A machine can be assigned at most one process.\nRate Matrix. The rate matrix R is also a |M| × P| matrix.\nThe field R(mi, pj) indicates the rate, in runs per timestep,\nthat machine mi runs process pj at. The rate matrix allows\nthe rate that a machine runs its process at to be decreased,\nsynchronizing it with the rest of the factory. A machine mi\ncan only run a process pj at a non-zero rate iff it is assigned\nthat process. The maximum rate that machine mi can run a\nprocess pj ∈P(mi) at is RUNTIME(mi, pj)−1. A machine\nruns a process at less than maximum rate by idling for a\nshort time after each run.\nTransport Plan. A transport plan (I, O, π, σ) describes\nhow tokens move through the factory. It specifies the state\n(π(ai, t), σ(ai, t)) of each agent ai ∈A and the tokens in\nthe input and output buffers (I(mi, t), O(mi, t)) of each\nmachine mi ∈M at each timestep t.\nA factory may need to run a manufacturing procedure for\nan indefinite amount of time. We thus need to find a cyclic\ntransport plan [10], a transport plan which can be looped\nrepeatedly. A cyclic transport plan has a cycle time Tc and\nan agent permutation Ω: A →A. It runs from timestep\nt = 0 to t = Tc. The tokens in each machine’s input buffer\nand output buffer at t = 0 and t = Tc must be the same:\n∀mi ∈M, I(mi, 0) = I(mi, Tc) ∧O(mi, 0) = O(mi, Tc).\nAn agent ai ∈A must be in the same state at timestep\nt = 0 as the agent Ω(ai) at timestep t = Tc:\n∀ai ∈A, π(ai, 0) = π(Ω(ai), T) ∧σ(ai, 0) = σ(Ω(ai), T).\nA cyclic transport plan can be looped by following the\nplan from t = 0 to t = Tc, relabelling the agents in A\naccording to the permutation Ω, and repeating.\nE. The Smart Factory Embedding Problem\nThe throughput θ(A, R, I, O, π, σ) of an embedding is\nthe total rate at which its machines run its output process:\nθ(A, R, I, O, π, σ) :=\nX\nmi∈M\n1\nR(mi, OUT(P)).\nIn the Smart Factory Embedding Problem (SFEP), we\nare given a manufacturing procedure (Z, P, OUT(P)) and\na smart factory (M, G, A) and asked to find a maximal\nthroughput embedding (A, R, I, O, π, σ).\nIII. RELATED WORK\nThe Multi-Agent Path Finding (MAPF) problem is the\nproblem of moving a team of agents from their starting\npositions to their goal positions without a collision. MAPF is\nan important component of the SFEP. The MAPF problem\nhas been solved in a number of different ways, including\nprioritized planning [11], search [12], answer set program-\nming [13], rule-based AI [14] and SAT solving [15].\nMAPF has been studied in the context of other optimiza-\ntion problems. One problem that involves MAPF which is\nrelated to the SFEP is the Collective Construction Prob-\nlem [16]. In the CCP, a team of agents is asked to construct\na structure out of building blocks. These building blocks are\nthe same size as the robots, forcing the robots to scale the\nstructure to position the blocks. The CCP is modelled as a\ncombinatorial optimization problem and solved for a single\nagent using dynamic programming in [17]. This algorithm\nis extended to multiple agents in [18]. Its solutions, how-\never, achieve little parallelism. The reinforcement learning\napproach developed in [19] improves parallelism. Optimal\nsolutions to the CCP based on constraint set programming\nand mixed integer linear programming are proposed in [20].\nTo our knowledge, the problem of jointly optimizing the\nassignment of processes to machines and the paths that\nagents follow to carry materials between machines in a smart\nfactory is not well studied. We believe that we are the first to\nmodel this problem as a combinatorial optimization problem.\nA number of systems for coordinating mobile robots in a\nmanufacturing plant have been proposed. For example, in [7],\nthe authors coordinate mobile robots in a manufacturing plant\nusing a traffic system. In [8], a distributed petri-net assigns\ntasks to mobile robots and coordinates traffic in a flexible\nmanufacturing system. Neither of these systems, however,\noptimizes the assignment of processes to machines.\nIV. APPROACH\nWe solve the SFEP in two stages. First, we construct a\nsimplified variant of the SFEP, which we term the Fixed\ncycle Length, Agent-Token SFEP (FLAT SFEP). We use this\nsolution to construct ACES, a solution to the full SFEP.\nA. The Fixed Cycle Length, Agent-Token SFEP\nThere are 3 differences between the FLAT and full SFEP.\nDifference 1. Fixed Cycle Length. In the full SFEP, a trans-\nport plan can have any cycle length. In the FLAT SFEP, the\ntransport plan’s cycle length is specified in the problem.\nDifference 2. Agent-Tokens. In the FLAT SFEP, tokens are\nmodeled as agents which move under their own power.\nTokens in the FLAT SFEP move analogously to agents in the\nfull SFEP. Each timestep, a token must move to an adjacent\ncell, remain at its current cell, or enter a machine’s input\nbuffer. Two tokens may not occupy the same cell or traverse\nthe same edge in the movement graph on the same timestep.\nA token may only enter a machine’s input buffer from\nits input cell. When a token enters a buffer, it is replaced\nby a null token. Null tokens may not enter a buffer. Each\n\n\ntimestep, if a machine’s output cell contains a null token,\nthe machine may replace the null token with a token from\nits output buffer. A token may not move on the timestep in\nwhich it is placed on the factory floor. There may only be n\ntokens on the factory floor at any time.\nDifference 3. Embedding. A FLAT SFEP embedding has a\ntransport plan for tokens instead of agents. It is an 8-tuple\n(A, R, I, O, at, mv, pl, rm) with 4 new components:\nPosition Tensor. The position tensor at is a |C|×(Tc +1)×\n|Z0| tensor which describes the positions of the tokens on the\nfactory floor. Let [0..x] be the set of integers {0, 1, . . . , x}.\nThe field at(ci, t, zj) ∈[0..n] specifies the number of copies\nof token zj at cell ci on timestep t. If there is more than one\ntoken at cell ci on timestep t, a collision has occured.\nMovement Tensor. Knowing the position of each token on\neach timestep does not tell you how the tokens move. Since\ncopies of the same token are indistinguishable, there may be\nmultiple ways to produce the configuration of tokens seen\nat timestep t + 1 from the configuration seen at timestep t.\nThe movement tensor mv, a |E| × (Tc + 1) × |Z0| tensor,\neliminates this ambiguity. Recall that each vertex in the\nmovement graph has a self-loop. The field mv(ci, cj, t, zk) ∈\n{0, 1} indicates iff a copy of token zk:\n• moves from ci to cj on timestep t when ci ̸= cj\n• waits at ci on timestep t when ci = cj\nPlacement and Removal Tensors. + The fields pl(ci, t, zj) ∈\n{0, 1} and rm(ci, t, zj) ∈{0, 1} indicate that a copy token\nzj was removed and placed on cell ci at timestep t.\nB. Why is introducing the FLAT SFEP helpful?\nThe SFEP can be formulated as an Mixed Integer Linear\nProgram (MILP). Unfortunately, this approach scales poorly.\nMAPF is an key part of the SFEP. Using a MILP to solve\nMAPF instances with dozens of agents takes a long time.\nAs a result, solving SFEP instances with many agents using\na MILP is impractically slow. The FLAT SFEP is easier to\nsolve as a MILP than the SFEP because it involves fewer\nvariables. A MILP formulation of the SFEP needs to contain\na binary variable indicating if cell ci contains agent aj\non timestep t for every (cell, timestep, agent) combination.\nA SFEP instance may have dozens of agents. Its optimal\nembedding may contain dozens of timesteps. As a result,\nthere may be thousands of these variables. The FLAT SFEP\nneeds fewer of these variables since there are usually fewer\ntokens than agents and it has a limited number of timesteps.\nC. Solving the FLAT SFEP\nWe solve the FLAT SFEP by formulating it as an MILP.\nThe MILP determines the contents of the tensors A, R, at,\nmv, pl and rm. We then select the contents of each buffer\nat timestep t = 0, fixing their contents on all other timesteps\nand thus the contents of the matrices I and O.\nObjective. We maximize the throughput θ of our embedding:\nmax\nX\nmi∈M\nR(mi, OUT(P))\nConstraints. Our formulation has three types of constraints:\nmachine configuration constraints, buffer entry and exit con-\nstraints, and token movement constraints.\nMachine Configuration Constraints. These constraints spec-\nify how each machine can be configured.\nConstraint 1. A machine is assigned at most 1 process.\n∀mi ∈M,\nX\npj∈P\nA(mi, pj) ≤1.\nConstraint 2. A machine must able to run its process.\n∀mi ∈M, ∀pj ∈P \\ P(mi), A(mi, pj) = 0.\nConstraint 3. Machine mi can only run a process pj ∈\nP(mi) once every RUNTIME(mi, pj) timesteps.\n∀mi ∈M, ∀pj ∈P(mi), R(mi, pj) ≤RUNTIME(mi, pj)−1\nConstraint 4. Machine mi can only run process pj at a non-\nzero rate if machine mi is assigned process pj.\n∀mi ∈M, ∀pj ∈P, R(mi, pj) −A(mi, pj) ≤0.\nToken Movement Constraints. These constraints specify how\ntokens move through the factory.\nConstraint 5. Over the course of a transport plan, the number\nof copies of each non-null token zj ∈Z that machine mi\nconsumes and that enter its input buffer must be the same.\n∀mi ∈M, ∀zj ∈Z,\nX\nt∈[0..Tc]\nrm(Cin(mi), t, zj) =\nX\npk∈P\nR(mi, pj) · inj(pk) · Tc.\nConstraint 6. Over the course of a transport plan, the number\nof copies of each non-null token zj ∈Z that machine mi\nemits and that exit its output buffer must be the same.\n∀mi ∈M, ∀zj ∈Z,\nX\nt=[0..Tc]\npl(Cout(mi), t, zj) =\nX\npk∈P\nR(mi, pj) · outj(pk) · Tc.\nConstraint 7. Each timestep t, a token zj ∈Z0 must wait at\nits cell, move to an adjacent cell, or be removed from the\nfactory floor. Recall that each vertex in the movement graph\nhas a self-loop, and that the field mv(ci, ci, t, zj) indicates\nif token zj waits at cell ci on timestep t.\n∀ci, t, zj ∈C × [0..Tc] × Z0, at(ci, t, zj) =\nX\n(ci,ck)∈E\nmv(ci, ck, t, zj) +\n(\nrm(ci, t, zj)\nci ∈Cio\n0\notherwise .\nConstraint 8. The number of copies of token zj ∈Z0 at cell\nci on timestep t + 1 is equal to the number of copies of zj\nthat wait at, move to, or are placed on cell ci on timestep t.\n∀ci, t, zj ∈C × [0..Tc] × Z0, at(ci, t + 1, zj) =\nX\n(ck,ci)∈E\nmv(ck, ci, t, zj) +\n(\npl(ci, t, zj)\nci ∈Cio\n0\notherwise .\n\n\nAlgorithm 1 ACES(Z, P, OUT(P), M, G, timer)\n1: emb∗←NULL\n// Best embedding constructed\n2: θ∗←0\n// Throughput of best embedding\n3: Tc ←1\n// Current cycle time\n4: while timer has not run out of time do\n5:\nemb, θ ←FLATSFEP(Z, P, OUT(P), M, G, Tc, timer)\n6:\nif θ ̸= NULL ∧θ > θ∗then\n7:\nemb∗, θ∗←emb, θ\n8:\nTc ←Tc + 1\n9: return TOSFEPEMB(emb∗)\nConstraint 9. A cell may not contain two tokens at once.\n∀ci, t ∈C × [0..Tc],\nX\nzk∈Z0\nat(ci, t, zj) ≤1.\nTogether, constraints 7, 8 and 9 imply that at most one token\ncan be placed on or removed from a cell on any timestep.\nConstraint 10. If a non-null token z ∈Z is removed from\nan input cell, it must be replaced by a null token z0.\n∀ci, t ∈Cin × [0..Tc],\nX\nzk∈Z\nrm(ci, t, zj) = pl(ci, t, z0).\nConstraint 11. If a non-null token z ∈Z is placed on an\noutput cell, it must replace a null token z0.\n∀ci, t ∈Cout × [0..Tc],\nX\nzk∈Z\npl(ci, t, zj) = rm(ci, t, z0).\nConstraint 12. A non-null token zk ∈Z cannot be placed\non an input cell or removed from an output cell.\n∀ci, t, zj ∈Cin × [0..Tc] × Z, pl(ci, t, zj) = 0.\n∀ci, t, zj ∈Cout × [0..Tc] × Z, rm(ci, t, zj) = 0.\nConstraint 13. A null token z0 cannot be placed on an output\ncell or removed from an input cell.\n∀ci, t ∈Cout × [0..Tc], pl(ci, t, z0) = 0.\n∀ci, t ∈Cin × [0..Tc], rm(ci, t, z0) = 0.\nConstraint 14. Two tokens may not traverse the same edge\nin the movement graph on the same timestep.\n∀(ci, cj), t ∈E × [0..Tc],\nX\nzk∈Z0\nmv(ci, cj, t, zk) + mv(cj, ci, t, zk) ≤1.\nConstraint 15. At most n tokens may be on the factory floor.\nX\nci∈C\nX\nzj∈Z0\nat(ci, t, zj) ≤n\nSelecting the Initial Contents of a Buffer. We initialize each\nmachine’s input buffer with the multiset of tokens that\nit consumes during the transport plan. As a result, even\nif replacement tokens arrive late, a machine will always\nhave enough tokens to run its process. We initialize each\nmachine’s output buffer with the multiset of tokens that it\nemits during the transport plan for similar reasons.\nAlgorithm 2 TOSFEPEMB(A, R, I, O, at, mv, pl, rm)\n1: π ←an empty n × (T + 1) matrix // Stores agent positions\n2: σ ←an empty n × (T + 1) matrix\n// Stores agent cargo\n3: i ←0\n// Agent index\n4: for (cj, zk) ∈C × Z do\n5:\nif at(cj, 0, zk) = 1 then\n6:\nπ(ai, 0) ←cj\n7:\nσ(ai, 0) ←zk\n8:\nfor t from 0 to Tc do\n9:\nfor (π(ai, t), cl) ∈E do\n10:\nif mv(π(ai, t), cl, t, σ(ai, t)) = 1 then\n11:\nπ(ai, t + 1) ←cl\n12:\nσ(ai, t + 1) ←σ(ai, t)\n13:\nif rm(π(ai, t), t, σ(ai, t)) then\n14:\nfor zm ∈Z0 do\n15:\nif pl(π(ai, t), t, zm) then\n16:\nπ(ai, t + 1) ←π(ai, t)\n17:\nσ(ai, t + 1) ←zm\n18:\ni ←i + 1\n19: return (A, R, I, O, π, σ)\nD. Solving the SFEP\nWe use our solution to the FLAT SFEP to construct\nACES. ACES is given in Algorithm 1. Let timer be a timer\nwhich triggers an interrupt after a specified amount of time.\nLet FLATSFEP(Z, P, OUT(P), M, G, Tc, timer) (Line 5)\nbe a implementation of our solution to the FLAT SFEP\nwhich returns an embedding and its throughput (emb, θ)\nif successful and the tuple (NULL, NULL) if interrupted\nby the timer. Finally, let TOSFEPEMB(emb∗) be a function\nwhich converts a FLAT SFEP embedding into a full SFEP\nembedding with the same throughput (Line 9). ACES’s\nmain loop (Lines 4-8) solves the FLAT SFEP problem for\nincrementally higher values of Tc until time runs out. ACES\nthen converts the best embedding found into a full SFEP\nembedding and returns it (Line 9).\nConverting a FLAT SFEP Embedding to a SFEP Embedding.\nTo convert a FLAT SFEP embedding into a SFEP embed-\nding, we need to convert its transport plan for agent-tokens\ninto a transport plan for regular agents. Our conversion\nalgorithm is shown in Algorithm 2. If cell cj contains a\ncopy of token zk at t = 0 in the FLAT SFEP embedding, we\nposition an agent ai carrying a copy of token zk on cell cj\nat t = 0 (Lines 5-7). Agent ai follows this token as it moves\nthrough the factory (Lines 9-12). If this token is replaced\nwith a copy of a new token zm, agent ai replaces its cargo\nwith a copy of token zm by picking up or depositing a token\nand then starts following this new token (Lines 13-17).\nE. Optimizing ACES\nACES is optimized in two ways.\nIgnoring Short Cycle Lengths. A cyclic transport plan must\nmove each agent ai ∈A from its start position to agent\nΩ(ai)’s starting position. Consequently, agent ai and Ω(ai)’s\nstarting positions can be at most Tc cells apart. When Tc is\nsmall, a transport plan must use relays of agents to cross large\ndistances. These relays require an impractical number of\nagents to construct. Consequently, we only generate transport\nplans with a cycle length greater than 4.\n\n\nFig. 2.\nThe FLAT SFEP solver’s throughput and runtime on the Benchmark Scenarios.\nScenario Name\nProcesses\nMachines\nMax Agents\nDrug Synthesis [24]\n8\n16\n100\nPill Production [25]\n8\n24\n100\nHard Candy Man. [26]\n8\n20\n100\nSmall-Scale Brewing [27]\n12\n16\n100\nContract Lens Man. [28]\n6\n24\n100\nLarge-Scale Brewing [27]\n12\n23\n100\nTABLE II\nBENCHMARK SCENARIO DETAILS\nLimiting the FLAT SFEP’s Runtime. A FLAT SFEP in-\nstance’s cycle length can make it difficult to solve. ACES\noften gets stuck on these hard instances. Limiting the FLAT\nSFEP’s runtime by asking it to return the best solution found\nin a given time frame increases the range of cycle length that\nACES examines, which can improve its solution quality.\nV. EVALUATIONS\nImplementation. We implement ACES in Python 3.11 [21].\nWe represent the layout graph with the NetworkX [22] li-\nbrary, and solve the FLAT SFEP as an ILP using Gurobi [23].\nMethodology. ACES is evaluated on 6 scenarios taken from\nthe pharmaceutical and food manufacturing industries. These\nindustries were chosen since they often require manufac-\nturers to produce many slightly different variations of the\nsame product. A hard candy manufacturer, for example,\noften wants to produce range of candy with different flavors.\nAs a result, these industries benefit heavily from flexible\nmanufacturing. Table II lists the number of processes and\nmachines and maximum number of agents allowed in each\nscenario. ACES was given a time limit of 30 minutes in each\nexperiment. This time limit is realistic since embeddings are\ncomputed offline. Its FLAT SFEP solver was set to time out\nafter 2.5 minutes.\nExperimental Hardware. Each evaluation was performed on\na 3.2 GHz, 8 Core AMD Ryzen 5800H CPU with 14 GB of\nRAM running Ubuntu 20.04.6 LTS.\nResults. The 1st and 3rd column of graphs show how the\ncycle length of a FLAT SFEP instance affects the throughput\nthat the FLAT SFEP solver achieves in each scenario. A\nthroughput of 0.0 indicates that the FLAT SFEP solver could\nnot solve that instance. The throughput of the FLAT SFEP\nsolver’s overall best embedding in each scenario is indicated\nwith a black line. There is little correlation between the\ncycle length of a FLAT SFEP instance and the throughput of\nits best solution. Our FLAT SFEP solver’s solution quality\ndecreases as the cycle length of a FLAT SFEP instance\nincreases, however, because it begins to time out before\nfinding an optimal solution. The FLAT SFEP solver never\nproduced a solution that used all 100 agents, suggesting that\nits throughput was limited by its machines.\nThe 2nd and 4th column of graphs show how the cycle\nlength of a FLAT SFEP instance affects the runtime of\nthe FLAT SFEP solver. Note that the FLAT SFEP solver\ntimed out after 150 seconds. Increasing the cycle length of\nan FLAT SFEP instance usually increases the FLAT SFEP\nsolver’s runtime. Interestingly, however, this is not always\ntrue. Certain cycle lengths make some FLAT SFEP instances\nvery easy to solve.\nVI. CONCLUSION\nIn this paper, we introduced the SFEP, formulated it\nas a combinatorial optimization problem, and addressed it\nwith ACES, the Anytime Cyclic Embedding Solver. We see\ntwo directions for future work. First, we plan to address\nlarger SFEP instances. Large automotive plants may operate\nhundreds of machines. ACES cannot scale to SFEP instances\nof that size. Second, we plan to allow machines to multi-task\nbetween processes. Multi-tasking is increasingly common in\nmodern smart factories, but we have neglected it in this paper.\n\n\nREFERENCES\n[1] J. M., A. Haleem, R. P. Singh, and R. Suman, “Enabling Flexible\nManufacturing System (FMS) through the Applications of Industry\n4.0 Technologies,” Internet of Things and Cyber-Physical Systems,\nvol. 2, pp. 49–62, 2022.\n[2] K. H¨ose, A. Amaral, U. G¨otze, and R. Pec¸as, “Manufacturing Flexi-\nbility through Industry 4.0 Technological Concepts—Impact and As-\nsessment,” Global Journal of Flexible Systems Management, vol. 24,\np. 289, 2023.\n[3] A. Owen-Hill, “10 Fantastic Examples of Flexible Manufacturing,”\n2023, accessed: 2024-09-16. [Online]. Available: https://robodk.com/\nblog/10-examples-of-flexible-manufacturing/\n[4] L. D. Evjemo, T. Gjerstad, E. I. Grotli, and G. Sziebig, “Trends in\nSmart Manufacturing: Role of Humans and Industrial Robots in Smart\nFactories,” Current Robotics Reports, vol. 1, pp. 35–41, 2020.\n[5] X. Zhao and T. Chidambareswaran, “Autonomous Mobile Robots in\nManufacturing Operations,” The International Conference on Automa-\ntion Science and Engineering, pp. 1–7, 2023.\n[6] BOSCH, “ctrlX Flow: Everything in the flow: Intralogistics Solutions\nfor the Smart Factory,” 2024, accessed: 2024-09-14. [Online].\nAvailable: https://apps.boschrexroth.com/microsites/ctrlx-automation/\nen/portfolio/ctrlx-flow/\n[7] M. Jasprabhjit, N. Mauludin, and R. Y. Zhong, “Smart Automated\nGuided Vehicles for Manufacturing in the Context of Industry 4.0,”\nProcedia Manufacturing, vol. 26, pp. 1077–1086, 2018.\n[8] D. Herrero-Perez and H. Martinez-Barbera, “Modeling Distributed\nTransportation Systems Composed of Flexible Automated Guided\nVehicles in Flexible Manufacturing Systems,” IEEE Transactions on\nIndustrial Informatics, vol. 6, no. 2, pp. 166–180, 2010.\n[9] P. Surynek, “Unifying Search-based and Compilation-based Ap-\nproaches to Multi-agent Path Finding through Satisfiability Modulo\nTheories,” The Twenty-Eighth International Joint Conference on Arti-\nficial Intelligence, p. 1177–1183, 2019.\n[10] C. Leet, C. Oh, M. Lora, S. Koenig, and P. Nuzzo, “Co-Design of\nTopology, Scheduling, and Path Planning in Automated Warehouses,”\nThe Design, Automation and Test in Europe Conference and Exhibi-\ntion, pp. 1–6, 2023.\n[11] P. Lozano-P´erez and M. Erdmann, “A novel approach to path planning\nfor multiple robots in bi-connected graphs,” Algorithmica, vol. 2, pp.\n477–521, 1987.\n[12] G. Sharon, R. Stern, A. Felner, and N. R. Sturtevant, “Conflict-Based\nSearch for Optimal Multi-Agent Path Finding,” Artificial Intelligence,\nvol. 219, p. 40–66, 2012.\n[13] V. Nguyen, P. Obermeier, T. C. Son, T. Schaub, and W. Yeoh,\n“Generalized Target Assignment and Path Finding Using Answer\nSet Programming.” The International Joint Conference on Artificial\nIntelligence, pp. 1216—-1223, 2017.\n[14] B. De Wilde, A. W. Ter Mors, and C. Witteveen, “Push and Rotate:\nA Complete Multi-Agent Pathfinding Algorithm,” Journal of Artificial\nIntelligence Research, vol. 51, no. 1, pp. 443––492, 2014.\n[15] J. Yu and S. LaValle, “Multi-agent Path Planning and Network Flow,”\nAlgorithmic Foundations of Robotics X: Proceedings of the Tenth\nWorkshop on the Algorithmic Foundations of Robotics, pp. 157—-173,\n2013.\n[16] H. Durrant-Whyte, N. Roy, and P. Abbeel, “TERMES: An Au-\ntonomous Robotic System for Three-Dimensional Collective Construc-\ntion,” Robotics: Science and Systems, pp. 257–264, 2012.\n[17] T. K. S. Kumar, S. Jung, and S. Koenig, “A Tree-Based Algorithm\nfor Construction Robots,” The International Conference on Automated\nPlanning and Scheduling, pp. 481–489, 2014.\n[18] T. Cai, D. Y. Zhang, T. K. S. Kumar, S. Koenig, and N. Ayanian,\n“Local Search on Trees and a Framework for Automated Construction\nUsing Multiple Identical Robots,” The 2016 International Conference\non Autonomous Agents and Multiagent Systems, p. 1301–1302, 2016.\n[19] G. Sartoretti, Y. Wu, W. Paivine, T. Kumar, S. Koenig, and H. Choset,\n“Distributed Reinforcement Learning for Multi-Robot Decentralized\nCollective Construction,” The International Symposium on Distributed\nAutonomous Robotic Systems, pp. 35—-49, 2018.\n[20] E. Lam, P. J. Stuckey, S. Koenig, and T. K. S. Kumar, “Exact\nApproaches to the Multi-agent Collective Construction Problem,” The\nInternational Conference on Principles and Practice of Constraint\nProgramming, pp. 743––758, 2020.\n[21] Python Software Foundation, “Python 3.11.10 Documentation,” 2024,\naccessed: 2024-09-15. [Online]. Available: https://docs.python.org/3.\n11/\n[22] A. A. Hagberg, D. A. Schult, and P. Swart, “Exploring Network\nStructure, Dynamics, and Function using NetworkX,” The 7th Python\nin Science Conference, pp. 11–15, 2008.\n[23] Gurobi Optimization, LLC, “Gurobi Optimizer Reference Manual,”\n2024, accessed: 2024-09-15. [Online]. Available: https://www.gurobi.\ncom\n[24] S. D. Schaber, D. I. Gerogiorgis, R. Ramachandran, J. M. B. Evans,\nP. I. Barton, and B. L. Trout, “Economic Analysis of Integrated\nContinuous and Batch Pharmaceutical Manufacturing: A Case Study,”\nIndustrial and Engineering Chemistry Research., pp. 10 083–10 092,\n2011.\n[25] R.\nSingh,\n“System\nEngineering\nfor\na\nNovel\nContinuous\nPharmaceutical Manufacturing Process,” 2019, accessed: 2024-09-15.\n[Online]. Available: https://www.pharmafocusasia.com/manufacturing/\nsystem-engineering-pharmaceutical-manufacturing-process\n[26] N. Efe and P. Dawson, “A Review: Sugar-Based Confectionery and\nthe Importance of Ingredients,” European Journal of Agriculture and\nFood Sciences, vol. 4, pp. 1–8, 2022.\n[27] L. H. G. van Donkelaar, J. Mostert, F. K. Zisopoulos, R. M. Boom,\nand v. A-J., “The Use of Enzymes for Beer Brewing: Thermodynamic\nComparison on Resource Use,” Energy, pp. 519–527, 2016.\n[28] J. Xu, Y. Xue, G. Hu, T. Lin, J. Gou, T. Yin, H. He, Y. Zhang, and\nX. Tang, “A comprehensive review on contact lens for ophthalmic\ndrug delivery,” Journal of Controlled Release, vol. 281, pp. 97–118,\n2018.\n\n\n",
  "metadata": {
    "source_file": "dataset/pdfs/arxiv_2502.21101v1.pdf",
    "total_pages": 7,
    "title": "Jointly Assigning Processes to Machines and Generating Plans for Autonomous Mobile Robots in a Smart Factory",
    "authors": [
      "Christopher Leet",
      "Aidan Sciortino",
      "Sven Koenig"
    ],
    "abstract": "A modern smart factory runs a manufacturing procedure using a collection of\nprogrammable machines. Typically, materials are ferried between these machines\nusing a team of mobile robots. To embed a manufacturing procedure in a smart\nfactory, a factory operator must a) assign its processes to the smart factory's\nmachines and b) determine how agents should carry materials between machines. A\ngood embedding maximizes the smart factory's throughput; the rate at which it\noutputs products. Existing smart factory management systems solve the\naforementioned problems sequentially, limiting the throughput that they can\nachieve. In this paper we introduce ACES, the Anytime Cyclic Embedding Solver,\nthe first solver which jointly optimizes the assignment of processes to\nmachines and the assignment of paths to agents. We evaluate ACES and show that\nit can scale to real industrial scenarios.",
    "published_date": "2025-02-28",
    "source": "arxiv"
  }
}