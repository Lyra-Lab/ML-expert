{
  "id": "arxiv_2502.21232v1",
  "text": "A quantum walk inspired model for distributed\ncomputing on arbitrary graphs\nMathieu Roget and Giuseppe Di Molfetta\nAix-Marseille Universit´e, Universit´e de Toulon, CNRS, LIS, Marseille,\nFrance.\n*Corresponding author(s). E-mail(s): mathieu.roget@lis-lab.fr;\nContributing authors: giuseppe.dimolfetta@lis-lab.fr;\nAbstract\nA discrete time quantum walk is known to be the single-particle sector of a\nquantum cellular automaton. For a long time, these models have interested the\ncommunity for their nice properties such as locality or translation invariance. This\nwork introduces a model of distributed computation for arbitrary graphs inspired\nby quantum cellular automata. As a by-product, we show how this model can\nreproduce the dynamic of a quantum walk on graphs. In this context, we inves-\ntigate the communication cost for two interaction schemes. Finally, we explain\nhow this particular quantum walk can be applied to solve the search problem and\npresent numerical results on different types of topologies.\nKeywords: Quantum Distributed Algorithm, Quantum Walk, Quantum Cellular\nAutomata, Quantum Anonymous Network, Searching Algorithm\nIntroduction\nQuantum Walks (QW), from a mathematical point of view, coincide with the single-\nparticle sector of quantum cellular automata (QCA), namely a spatially distributed\nnetwork of local quantum gates. Usually defined on a d-dimensional grid of cell, they\nare known to be capable of universal computation [1]. Both quantum walks and quan-\ntum cellular automata, with their beginnings in digital simulations of fundamental\nphysics [2, 3], come into their own in algorithmic search and optimization applica-\ntions [4]. Searching using QW has been extensively studied in the past decades, with a\nwide range of applications, including optimization [5] and machine learning [6]. On the\n1\narXiv:2502.21232v1  [quant-ph]  28 Feb 2025\n\n\nother hand, search algorithms as a field independent of quantum walks have recently\nbeen used, as subroutines, to solve distributed computational tasks [7–9]. However, in\nall these examples, some global information is supposed to be known by each node of\nthe network, such as the size, and usually the network is not anonymous, namely every\nnode has a unique label. Note that, the absence of anonymity and the quantum proper-\nties of the algorithm successfully solves the incalculability of certain problems such as\nthe leader election problem. However, encoding global information within a quantum\nstate is generally problematic. In order to address such issue, here we first introduce a\nnew QW-based scheme on arbitrary graphs for rephrasing search algorithms. Then we\nmove to the multi-qubits generalization, which successfully implements a QCA-based\ndistributed anonymous protocol for searching problems, avoiding any use of global\ninformation.\nContribution\nSection 1 of this work introduces a Quantum Walk model well suited to indifferently\nsearch for a node or edge in arbitrary graphs. In this model the walker’s amplitudes are\ndefined onto the graph’s edges and ensure 2-dimensional coin everywhere. We detail\nhow this Quantum Walk can be used to search a node or an edge and we show examples\nof this Quantum Walk on several graphs. In this first part, the Quantum Walk is\nintroduced formally as a discrete dynamical system. In Section 2 we move to the multi-\nparticle sector, allowing many quantum states-dynamics over the network, based on\nthe previous model, and leading to two distributed searching protocols. We consider\nhere two families of interaction graphs: all-to-all and cyclic. The implementations\nproposed conserves the graph locality and does not require a node or an edge to have\nglobal information such as the graph size. The nodes (and edges) do not have a unique\nlabel, and no leader is needed. Finally, Section 3 shows how to apply our model to\nthe search of edges or nodes. Numerical experiments for grids, hypercubes, complete\ngraphs, and random scale-free graphs are provided.\n1 Model of Quantum Walk on graphs\nThis section introduces our model of quantum walk on graphs and compare it to other\nsimilar models.\n1.1 The model\nWe consider an undirected connected graph G = (V, E), where V is the set of vertices\nand E the set of edges. We define the walker’s position on the graph’s edges and a\ncoin register of dimension two (either + or −). The full state of the walker at step t\nis noted :\n|Φt⟩=\nX\n(u,v)∈E\nψ+\nu,v |(u, v)⟩|+⟩+ ψ−\nu,v |(u, v)⟩|−⟩.\nThe graph is undirected so we indifferently use |(u, v)⟩and |(v, u)⟩to name the\nsame state. Similarly for the complex amplitudes ψ+\nu,v(t) = ψ−\nv,u(t). We also introduce\na polarity for every edge of G. For each of them, we have a polarity function σ, such\nthat : ∀(u, v) ∈E, σ(u, v) ∈{+, −} and σ(u, v) ̸= σ(v, u). Figure 1 illustrates how\n2\n\n\namplitudes and polarity are placed with edge (u, v) of polarity σ(u, v) = +. The\n(a) σ(u, v) = +\n(b) σ(u, v) = −\nFig. 1: The edge (u, v) and how are placed the amplitudes for the two possible polar-\nities.\npolarity is a necessary and arbitrary choice made at the algorithm’s initialization\nindependently for every edge. We discuss why it is necessary and a way to make\nthat choice at the end of this section. The full unitary evolution of the walk reads :\n|Φt+1⟩= S × (I ⊗C) × |Φt⟩, where C is the local coin operation acting on the coin\nregister :\n∀(u, v) ∈E, |(u, v)⟩|±⟩\ncoin\n7−→(I ⊗C) × |(u, v)⟩|±⟩= |(u, v)⟩(C |±⟩).\nand S is the scattering which moves the complex amplitudes ψ±\nu,v according to the\ncoin state. A practical choice for the scattering operator is the Grover diffusion as it\nis independent of the neighbors’ ordering:\n∀u ∈V,\n\u0010\nψσ(u,v)\nu,v\n\u0011\nv∈V\nscattering\n7−→\nDdeg(u) ×\n\u0010\nψσ(u,v)\nu,v\n\u0011\nv∈V ,\nwhere Dn =\n\u0000 2\nn\n\u0001\ni,j −In.\nAs an example of the above dynamics, one can consider the path of size 3 with\nthe nodes {u, v, w}, with polarity σ(u, v) = σ(v, w) = +. Figure 2 shows the unitary\nevolution of the walker from step t to step t+1, when the coin coincides with the first\nPauli matrix X.\nPolarity : Why and How\nThere are two reasons we need polarity. First, if the coin operator acts differently on\n|+⟩and |−⟩, then different polarities lead to different dynamics. Polarities, in fact,\ndetermines how each edge’s state scatters within the network, analogously to other\nspatial searching algorithms on regular lattice [10–13]. Moreover, polarity is used to\ndivide the edges in two. So each node can only access one amplitude of each edge\n(depending on the polarity of the edges). This makes things much simpler for a dis-\ntributed implementation, since we do not have to consider the case of two simultaneous\noperations on the same amplitude during scattering. One way to initialize the polar-\nity on the graph is to create a coloring of G at the initial time step. Afterward, edges\nhave their + pole in the direction of the node with the higher color. This design is\nespecially convenient for bipartite graphs where every node sees only + polarities or\nonly −polarities.\n3\n\n\nFig. 2: Example of a walk on a path of size 3.\n1.2 Relation with other models\nIn this subsection, we would like to discuss the relation between our model of discrete\ntime quantum walk on graphs and other existing models in the literature: the flip-flop\nquantum walk and the Szegedy quantum walk.\nFlip-flop quantum walk\nThe flip-flop quantum walk model is the closest from ours. The walker’s position is\ndefined onto the nodes of the graph and state |u⟩|v⟩symbolizes the walker being on\nnode u and going toward node v. The operation around the node that we call in our\nmodel scattering is now called the coin step as it acts without changing position of the\nflip-flop walker. The name flip-flop comes from the operation around the edges that\nacts by reversing origin and destination (Q : |u⟩|v⟩7→|v⟩|u⟩). The flip-flop quantum\nwalk coin dimension’s is variable which makes changing the coin unpractical. Moreover,\nit faces the same problem we face with edges, namely the ordering of the neighbors\nwhich makes the dynamic of the walker for non-regular graphs and a non-Grover coin\nchallenging. In contrast, the coin of our model is of dimension 2 and we provide the\nnotion of polarity, essential to define arbitrary coins. All in all, the flip-flop quantum\nwalk’s dynamic is equivalent to our model’s when our coin is set to X.\nSzegedy quantum walk\nThe Szegedy quantum walk does not include a coin operator. It is defined from a\nMarkov chain P. Let us define the projections\nΠA =\nX\nx\n|αx⟩⟨αx|\nand\nΠB =\nX\ny\n|βy⟩⟨βy| ,\n4\n\n\nwhere\n|αx⟩= |x⟩⊗\nX\ny\nPx,y |y⟩\nand\n|βy⟩=\nX\nx\nPy,x |x⟩⊗|y⟩.\nFor one time step, the unitary evolution reads U = (2ΠB −I)(2ΠA −I). Now, let’s\nnote that if we apply the flip-flop operation Q on |βy⟩we obtain |αy⟩. Thus it holds\nthat U = Q(2ΠA −I)Q(2ΠA −I). Therefore we can consider that (2ΠA −I) is a\nspecial scattering (for our model) or a special coin (for the flip-flop model) and Q the\nbasic operation around the edges. Thus we get a model really similar to both previous\nones, at the difference that two steps are made each iteration. We can also go further\nand look at the basic Markov chain used, which is Px,y =\n1\ndeg x. In such case, one can\nshow that (2ΠA −I) is actually the Grover diffusion around every node. This allows\nus to retrieve the same dynamic as the Grover flip-flop walk or our model with Grover\ndiffusion and coin X. The difference between the previous model lies in the what can\nbe changed. Indeed, the Szegedy’s model only allow to change the scattering through\nthe Markov chain P. However, its properties are strongly linked to the Markov chain\nP which makes obtaining analytical results much easier.\nWhat about searching ?\nOne of the most well known applications of quantum walks is searching. In doing so,\none or several positions are marked in some way, often through an oracle like in the\nGrover algorithm. This leads to a sinusoidal probability to be on a marked position,\nsimilar to the Grover algorithm’s one. And as in the Grover algorithm, the complexity\n(composed of the probability of success and hitting time) is going to depend on the\nactual number of amplitudes marked. In that regard, our model differs from the two\nothers as its walker is located onto the edges. This means that an oracle should mark\nthe edges of the graph, not the nodes. This also means that only two amplitudes per\nedge are be marked. In contrast, the two other models mark nodes which means d\namplitudes are marked. However, our model is searching edges while the two others\nare searching nodes. It is possible through self loops or other tricks to use our model\nto search nodes, but as we mark less amplitudes, the performances are going to be\nlower in the general case. However, the fact that we are marking a constant number of\namplitudes mights make studying our model easier for complex topologies. Note that\nSzegedy quantum walk marks nodes through changing the Markov chain which makes\nobtaining analytical results much easier.\nConclusion\nIn conclusion, the three models are really similar. Their dynamics can be made iden-\ntical by choosing the right setting. However, each of them has different pros and cons.\nOur model has a coin of dimension 2 and makes it possible to search edges. The flip-\nflop model insists more on changing the operations around nodes and does a better\njob at searching nodes. Finally the Szegedy quantum walk loses a bit of the freedom\nof the two previous models but allows solid analytical results both for the dynamics\nand searching.\n5\n\n\n2 Distributed implementation\nIn this section we move to the multi-particle states dynamics, allowing a distributed\nimplementation of the above quantum walk. We first introduce the model of dis-\ntributed computation we use, then we present two distributed protocols to reproduce\nthe dynamic of the walk.\n2.1 Model of distributed quantum computation\nThe computation model we consider is a network of qubits, following the topology\nof a given graph G = (V, E). We place qubits on both edges and nodes. We assume\nthat both nodes and edges can apply one and two qubits quantum gates. As usual,\nthe applications of quantum gates is supervised by classical algorithms. In order to\nexhibit the communications between the qubits, we sometimes explicit these classical\nalgorithms. The communication cost is calculated by the number of two-qubits gates\napplied between neighboring qubits. This model is represented in Figure 3.\nEdge register\nEach edge (u, v) has a register of two qubits respectively noted q(u,v) and q(v,u). These\ntwo qubits are connected with each other (i.e. we can apply two qubits gate between\nthem). Figure 3 shows the qubits as black dot and the connection between two qubits\nof one edge in serpentine red lines. Applying a gate between these two qubits is counted\nas an edge communication.\nNode register\nSimilarly to the edges, each node hosts qubits. Here we consider two cases according\nto the connectivity between the qubits inside the nodes. Either the qubits are all-to-\nall connected or they are connected in a cycle. An all-to-all connectivity implies that\nall the qubits of a node u are connected between each other and connected to all the\nedge qubits around node u. A cycle connectivity implies that the qubits of a node are\nconnected in a cycle and each node qubit is connected to one edge qubit. These two\nconnectivities are represented in the dotted boxes of Figure 3. For our goal, which is\nto use this model to reproduce the dynamic of the quantum walk of Section 1, using\nO(log d) qubits per node for the all-to-all connectivity or 2n qubits per node for the\ncycle connectivity is sufficient.\n2.2 Reproduction of the quantum walk’s dynamic\nThere are two main points allowing us to reproduce the dynamic of Section 1’ quantum\nwalk. First, we associate each amplitude of the quantum walk to a qubit of the model\nrepresented in Figure 3. Thus the qubit q(u,v) of the distributed model is associated to\nthe amplitude |u, v⟩|σ(u, v)⟩of the quantum walk. All the other qubits (situated on\nthe nodes) are considered anscillary qubits and will never be measured. The second\npoint regards the states we are allowed to use. Indeed, we restrict ourselves to linear\ndecomposition of unary states. Here, we call unary states a state in which all the\nqubits are at |0⟩except exactly one, which is at |1⟩. An example of such unary state\n6\n\n\nAll-to-all\nconnectivity\nCycle\nconnectivity\nu5\nu0\nu1\nu2\nu3\nu4\nO(log d)\nu\n:\nnode\n:\nedge\n:\nqubit\n:\nedge connection\n:\nnode connection\n:\nnode/edge connection\nk\n: k qubits all-to-all connected\nFig. 3: A graphical representation of the model of distributed computation. Show how\nthe qubits are positioned and connected for a given graph. Two node connectivity are\nconsidered: all-to-all and cycle.\nis the well known W state defined as\nW =\n1\n√\n3 (|001⟩+ |010⟩+ |100⟩) .\nEdges Register\nThe edge register represents the position of the walker and is the one measured at the\nend of the algorithm. It consists of two qubits per edge, corresponding, respectively,\nto the + and - polarity amplitudes. For the sake of simplifying the notations, let us\narbitrary enumerate the edges of E such that we have E = {e1, . . . , e|E|}. We define\nδn\nk =\n0 . . . 0\n| {z }\nk−1 times\n1 0 . . . 0\n| {z }\nn−k times\n. The complete state of the walk is a linear combination of\nall the\n\u0010\n|δ2|E|\nk\n⟩\n\u0011\nk∈2|E|, where |δ2|E|\n2k ⟩corresponds to the amplitude |ek⟩|+⟩of the local\nmodel, and |δ2|E|\n2k+1⟩corresponds to amplitude |ek⟩|−⟩. It is important that the global\nstate of the register remains a superposition of\n\u0010\n|δ2|E|\nk\n⟩\n\u0011\nk∈2|E|, as this allows us to\n7\n\n\nobtain a valid solution to the search problem during measurement. In fact, no matter\nwhich state δ2|E|\nk\nis measured, all edges measure state 0 except one, which measures\nstate 1.\nCoin\nIn the distributed model, the coin operation translates to the application of a 4 × 4\nunitary acting on the subspace composed of the unary states. We call this kind of\nunitary a unary extension, defined as follows :\nDefinition 1. Let us have a n × n unitary U. We call Λ(U) (of size 2n × 2n) the\nunary extension of U. Λ(U) satisfies the following properties:\n∀x ∈{0, . . . , n −1},\nU |x⟩=\nn−1\nX\ni=0\nai |i⟩⇒Λ(U) |δn\nx⟩=\nn−1\nX\ni=0\nai |δn\ni ⟩,\nand\nΛ(U) |0 . . . 0⟩= |0 . . . 0⟩.\nTherefore, we want to apply the unary extension of the coin C on the edge qubits\nof each edge of the distributed model. As shown in Theorem 1, there is a circuit of\ndepth O(1) that applies Λ(C) on e2i, e2i+1.\nTheorem 1. Let U be a 2 × 2 unitary operator (a one qubit gate). It holds that\nΛ(U) =\n\n\n\n\n1\n0\n0\n0\n0 U00 U01 0\n0 U10 U11 0\n0\n0\n0\n1\n\n\n\n.\nFurthermore, Λ(U) is realized by the following circuit:\n•\nU\n•\n•\nIn this circuit, the CNOT applications are forcing the controlled application of U\nto be applied only on the basis states |01⟩and |10⟩.\nScattering\nReproducing the scattering operation, like the coin operation, requires applying the\nunary extension of the scattering operator. This unary extension must be applied\nlocally around the nodes. The polarity ensures that these local scatterings commute\nand can be applied simultaneously. Hence, the distributed scheme for the scattering\naround one node is defined as follows.\nDefinition 2. Distributed scattering around a node Let v be a node of degree d.\nFurthermore, let us enumerate the quantum walk amplitudes around to v (as defined\nby the polarity) a0, . . . , ad−1 with the map\nϕ :\n\u001a\n2k\n7→|ek⟩|+⟩\n2k + 1 7→|ek⟩|−⟩\n8\n\n\nThis numbering can be imposed by the hardware or arbitrarily set and is necessary to\ndefine the scattering operator U(d). Note that the Grover diffusion operator is inde-\npendent of the numbering. In the quantum walk dynamic of Section 1, we apply U(d)\non Vec\n\u0010\n{ϕ(ai)}0≤k<d\n\u0011\n. In order to reproduce this dynamic with the distributed model,\nwe apply Λ(U) on the qubits a0, . . . , ad−1.\nIn the next sections, we present two ways to achieve that goal, one for each\nconnectivity considered in the distributed model (see Figure 3).\n2.3 Scattering operation with all-to-all connectivity\nIn this section, we consider the distributed model with all-to-all connectivity. We show\nhow to implement the scattering operation of the quantum walk dynamic presented\nin Section 1.\nAccording to Definition 2, we have an edge register E containing d qubits\na0, . . . , ad−1 where d is the degree of the node. In order to apply the scattering, we\nintroduce two ancillary registers N1 and N2 on the node. N1 contains ⌈log d⌉qubits\nand while N2 has one. We now define an operation T that transfers the unary state on\nregister E to the register N1 in a binary format while marking non-zero state transfers\nin register N2. Formally,\n∀k,\nT :\n\u001a|δd\nk⟩E |0⟩N1 |0⟩N2 7→|0⟩E |k⟩N1 |1⟩N2\n|0⟩E |0⟩N1 |0⟩N2 7→|0⟩E |0⟩N1 |0⟩N2\n.\nLet us denote the application of U(d) on register N1 controlled by register N2 as\nCN2[U(d)N1]. One can show that\nΛ(U)E ⊗IN1 ⊗IN2 = T −1 × (IE ⊗CN2[U(d)N1]) × T.\nIt is actually possible to decompose T into a product of d commutative operators\nTk, each acting on the registers N1 and N2 as well as qubit ak.\n∀k,\nTk :\n\u001a|1⟩ak |0⟩N1 |0⟩N2 7→|0⟩ak |k⟩N1 |1⟩N2\n|0⟩ak |0⟩N1 |0⟩N2 7→|0⟩ak |0⟩N1 |0⟩N2\n.\nIt holds that\nT =\nY\nk\nTk.\nIn Algorithm 1, we provide a distributed scheme for Tk. It is running on the node\nand it needs two communication methods: RequestCnot(edge, target), which applies\na Not on target controlled by the qubit in edge accessible, according to polarity; and\nApplyMCT(edge) which applies a Not on the edge’s qubit controlled by the full node\nregister N1 ∪N2. Note that, while ApplyMCT(edge) has significant computational cost,\nit is possible to limit the communication cost to one CNOT between the edge register\nand the node register by using an anscillary qubit as seen in Figure 4. The MCT\n(Multi-Controlled Tofolli gate) gate can then be applied on the node register with\ndepth O(d), as shown in Biswal et al [14].\n9\n\n\nq0\n•\n•\nq1\n•\n•\nq2\n•\nai\n≡\nq0\n•\nq1\n•\nq2\nai\nFig. 4: Application of a MCT (multi-controlled X gate) on an edge controlled by the\nwhole node register via a CNOT gate and an anscillary qubit. Q0, q1 are the qubits\nof the node register, q2 is the anscillary qubit and ai is the targeted edge qubit. Both\ncircuits are equivalent.\nAlgorithm 1 uses 1 + log d calls to RequestCnot(edge, target) and one call to\nApplyMCT(edge) which results in a communication cost of 2+log d CNOT between the\nnode and an edge. We need to apply it 2d times for one scattering. Thus one scattering\nadmits a communication cost of 2d(2 + log d) = O(d log d) CNOT.\nFinally, Figure 5 shows an example of this distributed design of the path graph\nof five nodes. The path graph has the particularity of having the same topology as\na circuit (a qubit being connected to the preceding and following qubit). Notice that\nsuch circuit coincides with a partitioned QCA, each operation is local and translational\ninvariant.\nAlgorithm 1 Distributed scheme for Tk on node u of degree d\nRequire: e an edge connected to u\nRequire: 1 ≤k ≤d\n1: function Tk(e, k)\n2:\nr ←⌈log d⌉\n▷The size of u’s register is r + 1\n3:\nfor 0 ≤i < r |\n\u0000(k −1)(2)\u0001\ni = 1 do\n4:\nRequestCnot(e, qi)\n▷CNOT on the ithqubit of u\n5:\nend for\n6:\nRequestCnot(e, qr)\n7:\nApply X gate on all qubits qi of u such that\n\u0000(k −1)(2)\u0001\ni = 0.\n8:\nApplyMCT(e)\n9:\nApply X gate on all qubits qi of u such that\n\u0000(k −1)(2)\u0001\ni = 0.\n10: end function\n2.4 QCA-like general scattering\nIn this section, we consider the distributed model with cycle connectivity as seen\nin Figure 3. Under this new connectivity, we show how to implement the scattering\noperation of the quantum walk dynamic presented in Section 1. The main idea here\nis to define a QCA-like dynamical system onto the node register that can implement\nany unitary. It is based on three following ideas:\n1. Any unitary can be decomposed into a product of two-levels unitaries.\n10\n\n\nu2 :\nX\n•\nX\n•\nX\n•\nX\nu1 :\n•\nD\n•\n(u, v)+ :\n×\nZ\n×\n•\n•\n(u, v)−:\n×\nZ\n×\n•\n•\nv2 :\nX\n•\nX\n•\n•\nX\n•\nX\n•\nv1 :\n•\n•\nD\n•\n•\n(v, w)−:\n×\n•\n•\n•\n•\n(v, w)+ :\n×\n•\n•\nw2 :\nX\n•\nX\n•\nX\n•\nX\nw1 :\n•\nD\n•\nFig. 5: Circuit of one step of the quantum walk for the path graph u −v −w. The\ncircuit applies successively the oracle on (u, v), the coin, T, D, T −1.\n2. There exists a quantum walk on the cycle with space-time dependent coin which\nimplements any given two-levels unitaries.\n3. The dynamic of a quantum walk on a cycle can be reproduced by a QCA (Quantum\nCellular Automata). The resulting unitary is exactly the unary extension of the\nquantum walk’s unitary.\nTherefore, to implement the scattering operation within our distributed model, first we\ndecompose the scattering operator U into two-levels unitaries. Then we calculate the\ncoefficients of the coin operators implementing the two-levels unitaries. And finally, we\napply the dynamic of the quantum walk on a cycle with the coin operators, previously\ncalculated via a QCA.\nIn the next three sections, we detail these ideas. Section 2.4.1 introduces the notion\nof two-levels unitaries and decomposition. The Theorem 3, in particular, show that an\napplication of the two-levels unitaries per batch is possible, optimizing the application\nof general unitaries. Section 2.4.2 presents in Theorem 4 a quantum walk on a cycle\nthat is able to implement any two-levels unitary. Algorithm 4 gives the procedure to\napply any unitary via a quantum walk on a cycle in O(d2) steps (where d is the dimen-\nsion of the unitary). Section 2.4.3 shows how the previous quantum walk dynamic can\nbe implemented with a QCA-like protocol that respects the topology represented in\nFigure 3. Figure 7, in particular, the resulting circuit.\n2.4.1 Decomposition of unitaries\nIn this section, we show how an unitary operator can be decomposed into two-levels\nunitaries,as in [15]. Two-levels unitaries are unitaries that only acts on two amplitudes.\nSimilarly, we can define a special type of two-levels unitariy that only act on one\namplitude as one-level unitary. Definition 3 and 4 give a more formal definition of\nthese objects and introduce notations to describe them.\n11\n\n\nDefinition 3. One-level unitary operator A one-level unitary operator is the tuple\n[c, k, n], where n ∈N, 0 ≤k < n and c ∈C. It denotes the following unitary operation:\n[c, k, n] = c |k⟩⟨k| +\nn−1\nX\ni = 0\ni ̸= k\n|i⟩⟨i| .\nDefinition 4. Two-levels unitary operator A two-level unitary operator is the tuple\n[U, k0, k1, n], where n ∈N, 0 ≤k0 ̸= k1 < n and U is a 2 × 2 unitary. It denotes the\nfollowing unitary operation:\n[U, k0, k1, n] =\n1\nX\ni,j=0\nUi,j |ki⟩⟨kj| +\nn−1\nX\ni = 0\ni /∈{k0, k1}\n|i⟩⟨i| .\nThe main tool at our disposal to decompose unitaries in two-levels unitaries is\nTheorem 2. This result allows us to find a two-levels unitary M such that multiplying\ntogether M and U makes one element of U under the diagonal vanish. If the process\nis repeated in the right order we can find two-levels unitaries M1, . . . , Mk such that\nM1 × U has one coordinate under the diagonal equal to 0, M2 × M1 × U has two, and\nso on and so far. Thus, Mk ×Mk−1 ×. . .×M1 ×U is upper triangular. Since the result\nof this product is both unitary and upper triangular, it is diagonal. Thus, we apply\none-level unitaries M ′1, . . . , M ′\nl in order to make all the diagonal coefficients equal to\none. Finally, we have\nM ′\nl × M ′\nl−1 × . . . × M ′\n1 × Mk × Mk−1 × . . . × M1 × U = I2.\nAnd we get the resulting decomposition\nM1 × M2 × . . . × Mk × M ′\n1 × . . . × M ′\nl = U.\nThis decomposition is detailed in Algorithm 2.\nTheorem 2. Let U be a n × n unitary and let 0 ≤k0 < k1 < n. It exists a two-levels\nunitary [TU, k0, k1, n] such that\n∀0 ≤i, j < n,\n{i, j} ∩{k1, k1} = ∅⇒([TU, k0, k1, n] × U)i,j = Ui,j,\nand\n([TU, k0, k1, n] × U)k1,k0 = 0.\nWe now present a way to apply these one-level and two-level unitaries per batch,\nwhere all the unitaries of one batch commuting with each others. This reduces the\ncomputational cost of implementing arbitrary unitaries since we can apply several\ntwo-levels unitaries at the same time.\n12\n\n\nAlgorithm 2 Two-level decomposition [15]\nRequire: U\nEnsure: n = dim U\nU1 ←U\nk ←1\nfor i in 0, . . . , n −1 do\nfor j in i + 1, . . . , n −1 do\nM ′\nk ←[TUk, i, j, n]\n▷According to Theorem 2\nM ←(M ′)† = [T †\nUk, i, j, n]\nUk+1 ←M ′\nk × Uk\nk ←k + 1\nend for\nend for\nfor i in 0, . . . , n −1 do\nMk ←[(Uk)i,i, i, n]\n▷one-level unitary\nUk+1 ←Uk\nk ←k + 1\nend for\nTheorem 3 (Batched application). For all unitary U, there exists B1, . . . , Bk sets of\none-level and two-level unitaries such that\nU =\n↷\nk\nY\ni=1\nY\nM∈Bk\nM,\nwhere k = O(dim U).\nThe one-level and two level unitaries of a same batch commute.\nProof. Using Theorem 2, we eliminate all the non-diagonal coordinates of U one by\none, essentially computing U †. The condition to that is to compute the two-level uni-\ntaries in the right order. Indeed, as long as the coordinates left and top of target\ncoordinate (k1, k0) of Theorem 2 are zero, then they will remain zero after appli-\ncation of a two-level unitary of the form [M, k0, k1, n]. Furthermore, two two-level\nunitaries [M1, k0, k1, n] and [M1, l0, l1, n] commutes if {k0, k1} ∩{l1, l1} = ∅as there\nnon-trivial operations are on different subspaces. Hence, we can organize the batches\nof target coordinates to eliminate at the same time all coordinates on the same off-\nantidiagonals (off-diagonals parallel to the antidiagonal). One last batch of one-level\nunitaries needs to be computed in order to finish the decomposition. As there is 2n−3\noff-antidiagonals, there is 2n −2 = O(n) batches. We provide a pseudo-code of this\nnew scheme in Algorithm 3.\n2.4.2 Application of a two-levels unitary with a cycle quantum walk\nNow we can show that the one-level and two-level unitaries may be rephrased in terms\nof a cyclic quantum walk. We define the quantum walk on the n sized cycle with two\n13\n\n\nAlgorithm 3 Batched two-level decomposition\nRequire: U\nEnsure: n = dim U\nU1 ←U\nk ←1\nfor s in 0, . . . , 2n do\nBk ←∅\nfor i in 0, . . . , n −1 do\nfor j in i + 1, . . . , n −1 do\nM ′ ←[TUk, i, j, n]\n▷According to Theroem 2\nM ←(M ′)† = [T †\nUk, i, j, n]\nBk ←Bk ∪{M}\nend for\nend for\nUk+1 ←\n\u0000 Q\nM∈Bk M\n\u0001\n× Uk\nk ←k + 1\nend for\nBk ←∅\nfor i in 0, . . . , n −1 do\nM ←[(Uk)i,i, i, n]\n▷one-level unitary\nBk ←Bk ∪{M}\nend for\nHilbert space: one for the position and one for the coin. Thus, the walker lives in\nHn ⊗H2. In order to fully define a quantum walk, apart from the space, we also need\nto define the coin and scattering operations. Here the scattering moves the walker to\nthe right when the coin state is |1⟩and keep the walker in-place otherwise. As for the\ncoin, we make it space-time dependent. More formally,\nState: |ψt⟩∈Hn ⊗H2,\nCoin: Ct =\nn−1\nX\ni=0\n|i⟩⟨i| ⊗Ct(i),\nScattering: S =\nn−1\nX\ni=0\n|i, 0⟩⟨i, 0| + |i + 1, 1⟩⟨i, 1|,\nUpdate rule at step t: QWt = S × Ct,\nDynamic from step t0 to step t1: QW(t0,t1) =\n↶\nt1\nY\nt=t0\nQWt = QWt1 × . . . × QWt0.\nOur goal is, given a target unitary T of dimension 2n, to chose a time tf and the\ncoins\n\u0000Ct(x)\n\u0001\n0 ≤t < tf\n0 ≤x < n\nsuch that QW(0,tf −1) = T. Theorem 4 shows how to do such\na thing for a batch of two-level unitaries while Theorem 5 shows how to do it for\ndiagonal matrices.\n14\n\n\nTheorem 4. Let there be a set of two-level unitaries\n\b\nTk = [Mk, 2x2k +v2k, 2x2k+1 +\nv2k+1, 2n]\n\t\nk with all X = {xi}i different pairwise. For all k and 0 ≤t < 2n, let\nCt(x2k) =\n\n\n\nX if (t ∈{0, n}) ∧(v2k = 1)\nMk\nif t = tk\nI\notherwise\n,\nCt(x2k+1) =\n\u001a\nX if (t ∈{0, n}) ∧(v2k+1 = 0)\nI\notherwise\n,\nwhere\ntk =\n\u001a\n(x2k −x2k+1 + n) mod n if x2k+1 ̸= x2k\nn\nif x2k+1 = x2k .\nIt holds that QW(0,2n−1) = Q\nk Tk.\nProof. We apply QW(0,2n−1) an all basis vectors and check the equality. There is three\ncases: |y⟩|v⟩, |x2k⟩|v⟩, |x2k+1⟩|v⟩where y /∈X and v ∈{0, 1}.\nCase 1:\nQW(0,2n−1) |y, v⟩=\n\n\n\n↶\n2n−1\nY\nt=0\nS × Ct\n\n\n× |y, v⟩\n=\n\n\n\n↶\n2n−1\nY\nt=0\nS × I\n\n\n|y, v⟩\n= S2n |y, v⟩\n= |y, v⟩\n=\n Y\ni\nTi\n!\n|y, v⟩.\n15\n\n\nCase 2:\nQW(0,2n−1) |x2k, v⟩=\n\n\n\n↶\n2n−1\nY\nt=0\nS × Ct\n\n\n× |x2k, v⟩\n=\n\n\n\n↶\n2n−1\nY\nt=1\nS × Ct\n\n\n× S × |x2k, 0⟩\n=\n\n\n\n↶\n2n−1\nY\nt=tk\nS × Ct\n\n\n× |x2k, 0⟩\n=\n\n\n\n↶\n2n−1\nY\nt=tk+1\nS × Ct\n\n\n× S × Mk |x2k, 0⟩\n=\n\n\n\n↶\n2n−1\nY\nt=n\nS × Ct\n\n\n× Mk |x2k, 0⟩\n=\n\n\n\n↶\n2n−1\nY\nt=n+1\nS × I\n\n\n× S × Mk |x2k, v⟩\n= Sn × Mk |x2k, v⟩\n= Mk |x2k, v⟩\n=\n Y\ni\nTi\n!\n|x2k, v⟩.\n16\n\n\nCase 3:\nQW(0,2n−1) |x2k+1, v⟩=\n\n\n\n↶\n2n−1\nY\nt=0\nS × Ct\n\n\n× |x2k+1, v⟩\n=\n\n\n\n↶\n2n−1\nY\nt=1\nS × Ct\n\n\n× S × |x2k+1, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=tk\nS × Ct\n\n\n× |x2k+1 + tk, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=tk\nS × Ct\n\n\n× |x2k, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=tk+1\nS × Ct\n\n\n× S × Mk |x2k, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=n\nS × Ct\n\n\n× Mk |x2k + n −tk, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=n\nS × Ct\n\n\n× Mk |x2k+1, 1⟩\n=\n\n\n\n↶\n2n−1\nY\nt=n+1\nS × I\n\n\n× S × Mk |x2k+1, v⟩\n= Sn × Mk |x2k+1, v⟩\n= Mk |x2k+1, v⟩\n=\n Y\ni\nTi\n!\n|x2k+1, v⟩.\nTheorem 5. Let there be a diagonal unitary D of size 2n × 2n. For all 0 ≤x < n\nand 0 ≤t < n, let\nCt(x) =\n\n\n\n\u0012\nD2x\n0\n0\nD2x+1\n\u0013\nif (t = 0)\nI\notherwise\n.\nIt holds that QW(0,2n−1) = D.\n17\n\n\nProof. First note that\nC0 =\nn−1\nX\nx=0\n|x⟩⟨x| ⊗\n\u0012\nD2x\n0\n0\nD2x+1\n\u0013\n= D.\nIt holds that\nQW(0,2n−1) =\n↶\n2n−1\nY\nt=0\nQWt\n=\n↶\n2n−1\nY\nt=0\n(S × Ct)\n=\n\n\n\n↶\n2n−1\nY\nt=1\n(S × Ct)\n\n\n× S × C0\n=\n\n\n\n↶\n2n−1\nY\nt=1\nS\n\n\n× S × D\n=\n\n\n\n↶\n2n−1\nY\nt=0\nS\n\n\n× D\n= D\nCombining those two results with Algorithm 3, we can, for a target uni-\ntary T, compute\nthe\ncoins\nCt(x)\nsuch\nthat U(0,tf −1)\n=\nT,\nwhere\ntf\n=\n2n\n|{z}\ncost of a batch\n×\n(8n −5)\n|\n{z\n}\nnumber of batches\n. The way to compute those coins is described in Algo-\nrithm 4.\n2.4.3 Scattering on the cycle\nWhile previous section shows how to apply an unitary via a quantum walk, it still\ndoes not solve the original problem of applying a distributed scattering. In order to do\nthat, we provide a distributed implementation of the previous cycle quantum walk. We\nrecall that according to Definition 2, we want to apply Λ(U) on the qubits a0, . . . , ad−1,\nfor a scattering operator U.\n18\n\n\nAlgorithm 4 Batched two-level application\nRequire: U\nEnsure: n = dim U\nU1 ←U\nk ←1\nfor s in 0, . . . , 2n do\n▷Lists the off-antidiagonals\nfor p in 0, 1 do ▷Ensures that all unitaries of the same batch acts on different\nposition\nBk ←∅\nfor i in 0, . . . , n −1 do\nfor j in i + 1, . . . , n −1 do\nM ′ ←[TUk, i, j, n]\n▷According to Theroem 2\nM ←(M ′)† = [T †\nUk, i, j, n]\nBk ←Bk ∪{M}\nend for\nend for\nUk+1 ←\n\u0000 Q\nM∈Bk M\n\u0001\n× Uk\nk ←k + 1\nend for\nend for\n\u0000Ct(x)\n\u0001\n0≤t<2n−1 ←Transpile(Uk)\n▷Compute Ct(x) for target Uk according to\nTheorem 5\nfor i in k −1, . . . , 0 do\n\u0000Ct(x)\n\u0001\n2nk≤t<2n(k+1)−1 ←Transpile(Ui)\n▷Compute Ct(x) for target Ui\naccording to Theorem 4\nend for\nLet\n\u0000Ct(x)\n\u0001\n0 ≤t < tf\n0 ≤x < d\nbe the coins of the cycle quantum walk QW of size d such\nthat\nQW(0,tf −1) =\n↶\ntf −1\nY\nt=0\n\u0000S ×\nn−1\nX\ni=0\n|i⟩⟨i| ⊗Ct(i)\n\u0001\n= T,\nwhere\nT = U ⊗|0⟩⟨0| + Id ⊗|1⟩⟨1|\nand\ntf =\nWe also introduce the anscillary qubits b0, . . . , bd−1 and c0, . . . , cd−1. Those are the\nnode register. We suppose the following connectivity:\n∀i, ai ∼bi ∼ci ∼bi+1,\nwhere ∼means ”is connected to”.\nThis connectivity, as well as the position of the qubits, is illustrated in Figure 6.\nWe want to apply Γ(T) on a0, b0, a1, b1, . . . , ad−1, bd−1.\nWe note M[q1,...,qn] the unitary operator M applied on qubits q1, . . . , qn.\n19\n\n\na0\nb0\nc0\na1\nb1\nc1\na2\nb2\nc2\na3\nb3\nc3\na4\nb4\nc4\nFig. 6: Connectivity of the qubits around a node.\nIt holds that\nΛ(Ct)[a0,b0,...,ad−1,bd−1] ⊗I[c0,...,cd−1] =\n\n\n\nd−1\nO\ni=0\nΛ(Ct(i))[ai,bi]\n|\n{z\n}\napplied on qubits ai and bi\n\n\n⊗I[c0,...,cd−1].\nAs Ct(i) are all 2 × 2 unitary and according to Theroem 1, Λ(Ct(i)) admits a circuit\nwith depth O(1). The two-qubits gates we apply are only between ai and bi ∀i, which\nare connected.\nIt holds that\nΛ(S)[a0,b0,...,ad−1,bd−1]⊗A[c0,...,cd−1] =\n\n\n\n\n\nd−1\nO\ni=0\nSWAP[bi,ci]\n|\n{z\n}\nswap bi and ci\n\n\n×\n\n\n\nd−1\nO\ni=0\nSWAP[ci,bi+1]\n|\n{z\n}\nswap ci and bi+1\n\n\n\n\n⊗I[a0,...,ad−1],\nwhere\nA |0, . . . , 0⟩= |0, . . . , 0⟩\nand\nA |δn\ni ⟩= |δn\ni−1⟩.\nWe need to apply two swaps, one between bi and ci, and the other one between ci and\nbi+1. This respects the connectivity between qubits.\nWe note\nΓ(QWt) =\n\u0000Λ(S)[a0,b0,...,ad−1,bd−1] ⊗A[c0,...,cd−1]\n\u0001\n×\n\u0000Λ(Ct)[a0,b0,...,ad−1,bd−1] ⊗I[c0,...,cd−1]\n\u0001\n.\n20\n\n\nb0\n•\n×\n×\n\n\n\n\n\n\n\n\n\n\n\n\n\nNode register\nc0\n× ×\nbi\n•\n× ×\nci\n× ×\nbd−1\n•\n× ×\ncd−1\n×\n×\na0\n•\nCt(0)\n•\nai\n•\nCt(i)\n•\n\n\n\n\n\n\n\n\n\nEdge register\nad−1\n•\nCt(d −1)\n•\nFig. 7: Circuit template for Λ(QWt)\nIt holds that\n↶\nt0+d\nY\nt=t0\nΛ(QWt) =\n↶\nt0+d\nY\nt=t0\n\u0000Λ(S × Ct)[a0,b0,...,ad−1,bd−1] ⊗A[c0,...,cd−1]\n\u0001\n=\n\n\n\n↶\nt0+d\nY\nt=t0\nΛ(S × Ct)[a0,b0,...,ad−1,bd−1]\n\n\n⊗\n\n\n\n↶\nt0+d\nY\nt=t0\nA[c0,...,cd−1]\n\n\n\n= Λ\n\n\n\n↶\nt0+d\nY\nt=t0\n(S × Ct)\n\n\n\n[a0,b0,...,ad−1,bd−1]\n⊗I[c0,...,cd−1]\n= Λ\n\u0000QW(t0,t0+d)\n\u0001\n[a0,b0,...,ad−1,bd−1] ⊗I[c0,...,cd−1].\nTherefor, the unary extension Λ(QW) of the quantum walk QW is defined by\nΛ(QW) =\n↶\ntf\nY\nt=0\nΛ(QWt),\nand satisfies\nΛ(QW) = Λ(T[a0,b0,...,ad−1,bd−1]) ⊗I[c0,...,cd−1] = Λ(U[a0,...,ad−1]) ⊗I[b0,c0,...,bd−1,cd−1].\nFurthermore, the unary extension Λ(QW) admits a circuit of depth O(d2) that respects\nthe connectivity ∀i, ai ∼bi ∼ci ∼bi+1 illustrated in Figure 6. This circuit’s template\nis provided in Figure 7.\n21\n\n\nNode connectivity\nEdge register\nNode register\nEdge cost\nNode cost\nEdge/node cost\nall-to-all\n2 qubits\nO (log d) qubits\nO (1)\nO (d + C(D))\nO (ln d) CNOT\ncycle\n2 qubits\nO (d) qubits\nO (1)\nO\n\u0000d2\u0001\nO (d) SWAP\nTable 1: Comparison table between the two methods. All information are given for one\narbitrary edge or one arbitrary node during one step of the QW’s dynamic. d is the degree\nof said node. C(D) is the cost (depth) of the diffusion operator D. Last column gives the\namount of operations between one edge and one node.\n2.5 Recap\nWe introduced a model of distributed quantum computation following the connectivity\nof a given graph. Two connectivities for the node registers have been considered: all-\nto-all and cycle. Furthermore, we showed that this model can be used to reproduce\nthe dynamic of the quantum walk on graphs introduced in Section 1. There are two\ndistributed protocols to reproduce this dynamic, one per connectivity considered for\nthe node registers. Table 1 shows a comparison between the two. In this table, the\ncost (number of two qubits gates) of the circuit inside an edge, the cost of the circuit\ninside a node and the cost between edges and nodes (for one edge and one node of\ndegree d) are all listed. Unsurprisingly, the first method with all-to-all connectivity\non the nodes performs better than the QCA-like approach. However, the latter only\nrequires cycle connectivity on the nodes.\nMoreover, the communication cost between two qubits of one edge is always O(1)\nswaps, and the communication cost between one edge and one node is O(ln d) =\nO(ln n) CNOT for all-to-all connectivity and O(d) = O(n) CNOT for cycle connectiv-\nity. Therefore, in general, a cycle connectivity fits the LOCAL model (i.e. O(poly(n))\ncommunication cost between two nodes each round) while one can fit the CONGEST\nmodel (i.e. O(log n) communication cost between two nodes each round) at the cost of\nall-to-all connectivity on the nodes. Note that this is for general topologies. In practice,\na grid or an hypercube fits the CONGEST model even with cycle connectivity.\n3 Application: Searching\nThis section shows how the quantum walk of section 1 can be used for searching. In this\nsection, we only consider the quantum walk and not its distributed implementation\npresented in section 2. This is because the dynamic is the same and studying the\nmathematical model of quantum walk is somewhat easier. We first detail how to search\nedges, before introducing a trick to search nodes. We conclude with some numerical\nexperiments.\n3.1 Searching an edge\nOur model formally describes a quantum walk on the graph’s edges. If the quantum\nstate is measured, we obtain one of the edges of the graph. This scheme is thus well\nsuited to search edges. Thus we may now introduce an oracle (i.e. a black box able\nto recognize/mark the solution to the searching problem) marking the desired edge\n22\n\n\n(a, b) ∈E. Analogously with the standard spatial search, the oracle is defined as\nfollows :\nOf =\n\n\nX\nf((u,v))=1\n|(u, v)⟩⟨(u, v)|\n\n⊗R +\n\n\nX\nf((u,v))=0\n|(u, v)⟩⟨(u, v)|\n\n⊗I2,\nwhere f is the classical oracle equals to 1 if and only if the edge is marked, and 0\notherwise. The operator R is a special coin operator which is applied only to the\nmarked edge. Without lack of generality, in the following we set C = X and R = −X.\nThe algorithm proposed here is the following : The initial state is initialized to be\nAlgorithm 5 Search a marked edge\nRequire: G = (V, E) undirected, connected graph\nRequire: f the classical oracle\nRequire: T ∈N the hitting time\n1: function Search(G, f, T)\n2:\n|Φ⟩←\n1\np\n2|E|\nX\n(u,v)∈E\n|(u, v)⟩|+⟩+ |(u, v)⟩|−⟩\n▷Diagonal initial state.\n3:\nfor 0 ≤i < T do\n4:\n|Φ⟩←S × (I ⊗C) × Of × |Φ⟩\n▷One step of the walk\n5:\nend for\n6:\n(u, v, ±) ←Measure(|Φ⟩)\n▷Measure the quantum state.\n7:\nreturn (u, v)\n8: end function\ndiagonal on the basis states and the additional oracle operation is added to the former\nQW-dynamic. There are two parameters that characterize the above algorithm : the\nprobability of success P of returning the marked edge and the hitting time T. The\nnumber of oracle calls of this algorithm is O(T). In practice, we want to choose T\nsuch that P is maximal. The previous algorithm can easily be made into a Las Vegas\nalgorithm whose answer is always correct but the running time random. Algorithm 6\nshows such transformation. Interestingly, the expected number of times Algorithm 6\ncalls Algorithm 5 is O(1/P) where P is the probability of success of Algorithm 5. The\nexpected complexity of Algorithm 6 is O (T/P) . The complexity of our algorithm is\nlimited by the optimal complexity of O(\n√\nK) for searching problem where K is the\ntotal number of elements. This is the complexity of the Grover algorithm which has\nbeen shown to be optimal [16]. However Grover’s algorithm assume full connectivity\nbetween elements which is not our case. The quantum walk presented here is on the\nedge of G, which means that the optimal complexity is O\n\u0010p\n|E|\n\u0011\n.\n23\n\n\nAlgorithm 6 Search a marked edge with guaranteed success\nRequire: G = (V, E) undirected, connected graph\nRequire: f, the classical oracle\nRequire: T ∈N the hitting time\n1: function GuaranteedSearch(G, f, T)\n2:\n(u, v) ←(nil, nil)\n▷Initial value\n3:\nwhile f((u, v)) ̸= 1 do\n▷Until we find the marked edge ...\n4:\n(u, v) ←Search(G, f, T)\n▷... search again.\n5:\nend while\n6:\nreturn (u, v)\n7: end function\n3.2 Example : Searching an Edge in the Star Graph\nIn this example we consider the star graph with M edges and M + 1 nodes; a graph\nwith M + 1 nodes where every node (other than node u0) is connected to node u0.\nOur searching algorithm performs well on this graph, as shown by Theorem 6. In\nthis section, we show the proof of Theorem 6 which is mainly spectral analysis on a\nsimplified dynamic.\nTheorem 6. Let G be the star graph with M edges. Algorithm 5 has an optimal hitting\ntime T = O\n\u0010√\nM\n\u0011\nand a probability of success O(1) for G. Algorithm 6 has expected\ncomplexity O\n\u0010√\nM\n\u0011\n.\nProof. We consider the star graph G = (V, E) of size M + 1 such that V\n=\n{u0, . . . , uM} and E\n= {(u0, ui) | 1 ≤i ≤M}. We assume without a loss\nof generality that the marked edge is (u0, u1) and that the polarity is ∀i >\n1,\nσ(u0, ui)\n=\n+. At any time step t, the state of the walk reads |Φt⟩\n=\nPM\ni=1 ψ+\nu0,ui(t) |(u0, ui)⟩|+⟩+ ψ−\nu0,ui(t) |(u0, ui)⟩|−⟩. We first show that ∀t ∈N, ∀i >\n1, ψ+\nu0,ui(t) = α+ and ψ−\nu0,ui(t) = α−. This greatly simplifies the way we describe\nthe walk dynamic. Afterward we shall provide simple spectral analysis to extract the\noptimal hitting time T and probability of success P. Next, we prove the property\n(Qt) :\n∀i > 1, ψ+\nu0,ui(t) = α+\nt and ψ−\nu0,ui(t) = α−\nt for all t ∈N.\nThe initial state |Ψ0⟩is diagonal on the basis states :\n|Φ⟩←\n1\np\n2|E|\nX\n(u,v)∈E\n|(u, v)⟩|+⟩+ |(u, v)⟩|−⟩.\nAll\n\u0000ψ±\nu0,ui(0)\n\u0001\ni≥1 are equals so the property Q0 is satisfied with α+\nt = α−\nt =\n1\n√\n2M .\nNow, we assume that Qt is true and use the walk dynamic to show that Qt+1 is also\ntrue. The state |Ψt+1⟩is described in Table 2 and show that Qt+1 is true.\nUsing the recurrence in Table 2, we can put the dynamic of the walk into a matrix\nform.\nψ−\nu0,u1(t) = (−1)\n√\n2M\nand\nXt+1 = AXt,\n24\n\n\nTable 2: Detailed dynamic of the quantum walk for star graphs.\nStep t\nAfter oracle\nAfter coin\nAfter Scattering\nα+\nα+\nt\nα+\nt\nα−\nt\nα+\nt+1 = (M −2)α−\nt −2ψ+\nu0,u1\nM\n(t)\nα−\nα−\nt\nα−\nt\nα+\nt\nα−\nt+1 = α+\nt\nψ+\nu0,u1\nψ+\nu0,u1(t)\n−ψ−\nu0,u1(t)\n−ψ+\nu0,u1(t)\nψ+\nu0,u1(t + 1) = (2M −2)α−\nt + (M −2)ψ+\nu0,u1\nM\n(t)\nψ−\nu0,u1\nψ−\nu0,u1(t)\n−ψ+\nu0,u1(t)\n−ψ−\nu0,u1(t)\nψ−\nu0,u1(t + 1) = −ψ−\nu0,u1(t)\nwhere\nXt =\n\n\nα+\nt\nα−\nt\nψ+\nu0,u1(t)\n\n\nand\nA =\n\n\n0\nM−2\nM\n−2\nM\n1\n0\n0\n0 2 M−1\nM\nM−2\nM\n\n.\nAfter\ndiagonalizing\nA,\nthe\neigenvalues\nare\n{−1, eiλ, e−iλ},\nwhere\neiλ\n=\nM−1+i√2M−1\nM\n. This leads to ψ+\nu0,u1(t) ∼\ni\n2\n\u0000e−iλt −eiλt\u0001\n∼sin(λt), which allows us\nto deduce the probability pt of hitting the marked edge pt ∼sin2(λt), and then the\noptimal hitting time by solving pT = 1:\nT = π\n2\n1\nλ ∼π\n2\nr\nM\n2 ∼\nπ\n2\n√\n2\n√\nM = O(\n√\nM).\nFinally we have a probability of success P ∼1 for the optimal hitting time T ∼\nπ\n2\n√\n2\n√\nM = O(\n√\nM).\n3.3 Searching Nodes\nThe searching quantum walk presented in the previous section can search one marked\nedge in a graph. In order to search a node instead, we need to transform the graph we\nwalk on. We call this transformation starify.\nDefinition 5. Starify\nLet us consider an undirected graph G = (V, E). The transformation starify on G\nreturns a graph ˜G for which\n• every node and edge in G is in ˜G (we call them real nodes and real edges).\n• for every node u ∈V , we add a node ˜u (we call these new nodes virtual nodes).\n• for every node u ∈V , we add the edge (u, ˜u) (we call these new edges virtual edges).\nWe call the resulting graph ˜G the starified graph of G.\n25\n\n\nSearching nodes\nStarifying a graph G allows us to search a marked node u instead of an edge. We can\nthen use the previous searching walk to search the virtual edge and then deduce with-\nout ambiguity the marked node u of the initial graph G. This procedure implies that\nwe have to increase the size of the graph (number of edges and nodes). In particular,\nincreasing the number of edges is significant since we increase the dimension of the\nwalker (this can be significant for sparse graphs) and one must be careful of this when\ncomputing the complexity. A reassuring result is that searching a node on the com-\nplete graph (the strongest possible connectivity) has optimal complexity. As stated\nin Theorem 7, the complexity is O(\n√\nM), which is optimal when searching over the\nedges. Compared to a classical algorithm in O(M) (a depth first search for instance),\nwe do have a quadratic speedup.\nTheorem 7. When using the quantum algorithm to search one marked node in the\nstarified graph ˜G of the complete graph G of size N, the probability of success is P ∼1\nand the hitting time T ∼π\n4 N.\nProof. The proof is very similar to the one of Theorem 6. We show that several edges\nhave the same states to reduce the dynamic to a simple recursive equation. We then\nsolve it numerically and derive asymptotic values for the probability of success.\n3.4 Numerical experiments\nThis section presents numerical results when searching nodes with our model on var-\nious graphs: grids, hypercubes, complete graphs and random scale-free graphs. The\ncodes to reproduce the figures in this section is available on a github1.\nSearching Searching nodes in a grid\nIn this section we consider the 2-dimensional square grid. Figure 8 shows the probabil-\nity of success and hitting time of the searching algorithm in function of ˜\nM for several\ngrid sizes. For a grid of size\n√\nN ×\n√\nN, it holds that ˜\nM = 3N. Linear fit are displayed\nin Figure 8 and show numerically that the probability of success P = O(\n1\nln ˜\nM ) and the\nhitting time T = O(\np\n˜\nM ln ˜\nM). Since ˜\nM and N differ only by a coefficient, the final\ncomplexity of the algorithm shall be O\n\u0012q\nN log\n3\n2 N\n\u0013\n.\nApplication: Searching nodes in a hypercube\nIn this section we consider the hypercube of dimension d. Figure 9 shows the prob-\nability of success and hitting time of the searching algorithm in function of\n˜\nM for\nseveral values of d. It holds that ˜\nM = 2d−1(2 + d) = O(N ln N). Linear fit are dis-\nplayed in Figure 9 and show numerically that the probability of success P = Ω(1) and\nthe hitting time T = O(\np\n˜\nM). Since ˜\nM = O(N ln N) , the final complexity of the\nalgorithm shall be O\n\u0010p\nN log⋆N\n\u0011\n. Note the the quantum walk is walking on the ˜\nM\nedges of the starified graph. Having a complexity of O( ˜\nM) means being optimal (in\n1https://github.com/mroget/code paper QWDistrib\n26\n\n\n8(a) Probability of success\n8(b) Hitting time\nFig. 8: Searching performances for a grid of size\n√\nN ×\n√\nN when N increases. Linear\nfits are displayed to exhibit the asymptotic behavior of the searching algorithm. We\nrecall that ˜\nM is the number of edges of starified graph.\n9(a) Probability of success\n9(b) Hitting time\nFig. 9: Searching performances for a hypercube of size N = 2d when N increases.\nLinear fits are displayed to exhibit the asymptotic behavior of the searching algorithm.\nWe recall that ˜\nM is the number of edges of starified graph.\nthe sense that we do as well as Grover and can’t do any better by searching on edges).\nHowever, focusing on the original problem of finding a node in the original graph, the\ncomplexity becomes slightly worse than Grover.\nApplication: Searching nodes in a complete graph\nIn this section we consider the complete graph of size N. Figure 10 shows the prob-\nability of success and hitting time of the searching algorithm in function of\n˜\nM for\nseveral values of N. It holds that ˜\nM = N + N 2/4. Linear fit are displayed in Figure\n10 and show numerically that the probability of success P = Ω(1) and the hitting\ntime T = O(\np\n˜\nM). Since ˜\nM = O(N 2) , the final complexity of the algorithm shall be\nO (N). Similarly to the hypercube, the QWSearch is optimal.\n27\n\n\n10(a) Probability of success\n10(b) Hitting time\nFig. 10: Searching performances for a complete graph of size N when N increases.\nLinear fits are displayed to exhibit the asymptotic behavior of the searching algorithm.\nWe recall that ˜\nM is the number of edges of starified graph.\nSearching nodes in random scale-free graphs\nIn this section we focus on random scale-free graphs. Figure 11 shows the probability\nof success and hitting time for every nodes of one random scale-free graph generated\nwith the Barab´asi–Albert algorithm[17]. The fit suggests the following relations:\nP = 1 −\n1\n1 + 3\n4N tan\n2d\nπ(N−1)\nand\nT 2 ∝N + M\nP\n,\nwhere d is the degree of the node marked. To confirm these relations, we randomly\ngenerated 1000 scale-free bipartite graphs (the parameters n, m have been randomly\nsampled between 100 and 200 for n and between 5n and n2/2 for m). We then look at\nthe mean square error and the coefficient of determination obtained when predicting\nthe probability of success and hitting time for every nodes of every graphs. These\nresults are presented in Table 3.\nmse\nscore\nT\n0.5237187281594099\n0.9985740735579267\nP\n2.5618806822927392e −06\n0.9986901398080446\nTable 3: Mean Square Error (mse) and coefficient\nof determination (score) when trying to fit the\nprobability of success and hitting time.\nConclusion\nIn this paper, we presented a new distributed model of quantum computation inspired\nby quantum cellular automata. This model preserves the nice properties that QCA\nhave, have, such as locality or translation invariance. Furthermore, this model is\n28\n\n\n11(a) Probability of success\n11(b) Hitting time\nFig. 11: Searching performances for a random scale-free graph of size 1000 with around\n9900 edges. Fits are displayed to exhibit the asymptotic behavior of the searching\nalgorithm. We recall that ˜\nM is the number of edges of starified graph.\ndefined on arbitrary topologies. A network of qubits is established, with a register of\ntwo qubits per edge and a multiple qubits register per node. Communications, in this\nmodel, are counted as the number of two-qubits gates applied. Moreover, two connec-\ntivities are considered for the qubits of one node: all-to-all and cycle. As an application,\nwe show how this model can simulate the dynamic of a quantum walk, as in [18].\nThis is a natural choice as a quantum walk formally coincides with the single parti-\ncle sector of a QCA. Two different protocols reproducing the quantum walk dynamic\nare considered, one for each node registers’ connectivities. Obviously, all-to-all con-\nnectivity has a smaller communication cost than cycle and always fits the CONGEST\nmodel of communication. However, even cycle connectivity fits the CONGEST model\nfor several topologies like grids or hypercubes.\nFinally, we present an application of this quantum walk to the searching problem.\nWe show how the dynamic of the quantum walk can be used to search a node and\nan edge on several graphs. Numerical results show a quadratic improvement of the\ncomplexity for almost all graphs tested. While these numerical results are for the\nquantum walk’s dynamic, it can be translated to a distributed framework since the\ndistributed scheme from Section 2 can perfectly reproduce said dynamic.\nTo go further, one could consider other dynamics besides the quantum walk.\nIndeed, while our model of computation has been inspired by quantum walks and\nimplements them well, it is more general than that. Further works could also been\ndone on exploiting the searching quantum walk in a distributed framework.\nAknowledgement\nThis work is supported by the PEPR EPiQ ANR-22-PETQ-0007, by the ANR JCJC\nDisQC ANR-22-CE47-0002-01.\nReferences\n[1] Arrighi, P.: An overview of quantum cellular automata. Natural Computing\n18(4), 885–899 (2019)\n29\n\n\n[2] Di Molfetta, G., Brachet, M., Debbasch, F.: Quantum walks as massless dirac\nfermions in curved space-time. Physical Review A 88(4), 042301 (2013)\n[3] Bisio, A., D’Ariano, G.M., Perinotti, P.: Quantum walks, deformed relativity\nand hopf algebra symmetries. Philosophical Transactions of the Royal Society A:\nMathematical, Physical and Engineering Sciences 374(2068), 20150232 (2016)\n[4] Santha, M.: Quantum walk based search algorithms. In: International Confer-\nence on Theory and Applications of Models of Computation, pp. 31–46 (2008).\nSpringer\n[5] Slate, N., Matwiejew, E., Marsh, S., Wang, J.B.: Quantum walk-based portfolio\noptimisation. Quantum 5, 513 (2021)\n[6] Melnikov, A.A., Fedichkin, L.E., Alodjants, A.: Predicting quantum advantage\nby quantum walk with convolutional neural networks. New Journal of Physics\n21(12), 125002 (2019)\n[7] Gall, F.L., Nishimura, H., Rosmanis, A.: Quantum advantage for the local model\nin distributed computing. arXiv preprint arXiv:1810.10838 (2018)\n[8] Le Gall, F., Magniez, F.: Sublinear-time quantum computation of the diameter\nin congest networks. In: Proceedings of the 2018 ACM Symposium on Principles\nof Distributed Computing, pp. 337–346 (2018)\n[9] Izumi, T., Gall, F.L., Magniez, F.: Quantum distributed algorithm for triangle\nfinding in the congest model. arXiv preprint arXiv:1908.11488 (2019)\n[10] Bezerra, G., Lug˜ao, P.H., Portugal, R.: Quantum-walk-based search algorithms\nwith multiple marked vertices. Physical Review A 103(6), 062202 (2021)\n[11] Arrighi, P., Di Molfetta, G., M´arquez-Mart´ın, I., P´erez, A.: Dirac equation as a\nquantum walk over the honeycomb and triangular lattices. Physical Review A\n97(6), 062111 (2018)\n[12] Roget, M., Guillet, S., Arrighi, P., Di Molfetta, G.: Grover search as a naturally\noccurring phenomenon. Physical Review Letters 124(18), 180501 (2020)\n[13] Portugal, R.: Quantum Walks and Search Algorithms vol. 19. Springer, ??? (2013)\n[14] Biswal, L., Bhattacharjee, D., Chattopadhyay, A., Rahaman, H.: Techniques for\nfault-tolerant decomposition of a multicontrolled toffoli gate. Physical Review A\n100(6), 062326 (2019)\n[15] Nielsen, M.A., Chuang, I.L.: Quantum Computation and Quantum Information.\nCambridge university press, ??? (2010)\n[16] Zalka, C.: Grover’s quantum searching algorithm is optimal. Physical Review A\n30\n\n\n60(4), 2746 (1999)\n[17] Barab´asi, A.-L., Albert, R.: Emergence of scaling in random networks. science\n286(5439), 509–512 (1999)\n[18] Roget, M., Di Molfetta, G.: A quantum walk-based scheme for distributed search-\ning on arbitrary graphs. In: Asian Symposium on Cellular Automata Technology,\npp. 72–83 (2024). Springer\n31\n\n\n",
  "metadata": {
    "source_file": "dataset/pdfs/arxiv_2502.21232v1.pdf",
    "total_pages": 31,
    "title": "A quantum walk inspired model for distributed computing on arbitrary graphs",
    "authors": [
      "Mathieu Roget",
      "Giuseppe Di Molfetta"
    ],
    "abstract": "A discrete time quantum walk is known to be the single-particle sector of a\nquantum cellular automaton. For a long time, these models have interested the\ncommunity for their nice properties such as locality or translation invariance.\nThis work introduces a model of distributed computation for arbitrary graphs\ninspired by quantum cellular automata. As a by-product, we show how this model\ncan reproduce the dynamic of a quantum walk on graphs. In this context, we\ninvestigate the communication cost for two interaction schemes. Finally, we\nexplain how this particular quantum walk can be applied to solve the search\nproblem and present numerical results on different types of topologies.",
    "published_date": "2025-02-28",
    "source": "arxiv"
  }
}